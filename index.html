<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Task Management Board</title>
  <link rel="icon" href="data:,">
  <script src="https://unpkg.com/konva@8.3.5/konva.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <style>
    @keyframes slide-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes fade-in {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .card-hover:hover { transform: scale(1.02); transition: transform 0.2s ease; }
    body.light { background-color: #f3f4f6; color: #1f2937; }
    body.light .bg-gray-800 { background-color: #ffffff; }
    body.light .bg-gray-700 { background-color: #e5e7eb; }
    #admin-panel, #auth-panel, #board-panel { z-index: 1000; }
    #canvas-container { position: relative; overflow: hidden; width: 100%; height: 100%; }
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center; }
    .modal-content { background: #1a202c; padding: 4px; border-radius: 8px; width: 90%; max-width: 400px; }
    @media (max-width: 600px) {
      #sidebar { width: 100%; height: 100%; position: fixed; top: 0; left: 0; transform: translateX(-100%); transition: transform 0.3s ease; z-index: 1500; }
      #sidebar.active { transform: translateX(0); }
      #canvas-container { width: 100%; height: calc(100vh - 48px); }
      .modal-content { width: 95%; padding: 10px; }
      #admin-panel { width: 100%; height: 100%; position: fixed; top: 0; right: 0; }
    }
  </style>
</head>
<body class="min-h-screen bg-gray-900 text-white overflow-hidden">
  <!-- Auth Panel -->
  <div id="auth-panel" class="flex flex-col items-center justify-center min-h-screen w-full bg-gray-800 p-4">
    <div class="text-center mb-6">
      <h2 class="text-2xl font-bold sm:text-3xl">Вход или регистрация</h2>
    </div>
    <div class="bg-gray-800 p-4 rounded-lg w-full max-w-md">
      <div id="email-auth">
        <input id="display-name" type="text" placeholder="Ваше имя" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <input id="email" type="email" placeholder="Email" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <input id="password" type="password" placeholder="Пароль" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <button id="login-btn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full mb-2 text-sm sm:text-base">Войти</button>
        <button id="register-btn" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 w-full text-sm sm:text-base">Зарегистрироваться</button>
      </div>
      <div class="mt-4 text-center">
        <button id="google-login-btn" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 w-full text-sm sm:text-base">Войти через Google</button>
      </div>
    </div>
  </div>

  <!-- Board Selection Panel -->
  <div id="board-panel" style="display: none;" class="flex flex-col items-center justify-center min-h-screen w-full bg-gray-800 p-4">
    <div class="bg-gray-800 p-4 rounded-lg w-full max-w-md">
      <h3 class="text-lg font-bold mb-4 sm:text-xl">Выберите действие</h3>
      <button id="create-board-btn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full mb-2 text-sm sm:text-base">Создать новую доску</button>
      <input id="join-link" type="text" placeholder="Вставьте ссылку-приглашение" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
      <button id="join-board-btn" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 w-full text-sm sm:text-base">Присоединиться к доске</button>
      <button id="export-boards-btn" class="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700 w-full mt-2 text-sm sm:text-base">Экспортировать доски</button>
      <input id="import-boards" type="file" accept=".json" class="w-full bg-gray-700 p-2 rounded mt-2 text-sm sm:text-base">
    </div>
  </div>

  <!-- Sidebar -->
  <div id="sidebar" style="display: none;" class="w-full bg-gray-800 p-4 flex flex-col sm:w-64 min-h-screen sm:min-h-screen slide-in">
    <h2 class="text-lg font-semibold mb-4 sm:text-xl">Роли и холсты</h2>
    <ul id="roles-list" class="space-y-2"></ul>
    <button id="toggle-admin" class="mt-auto bg-blue-600 text-white px-4 py-2 hover:bg-blue-700 transition text-sm sm:text-base">Админ-панель</button>
    <button id="logout-btn" class="mt-2 bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition text-sm sm:text-base">Выйти</button>
  </div>

  <!-- Admin Panel -->
  <div id="admin-panel" style="display: none;" class="w-full bg-gray-800 p-4 absolute right-0 top-0 h-full sm:w-80 sm:h-full">
    <h2 class="text-lg font-semibold mb-4 sm:text-xl">Админ-панель</h2>
    <div class="space-y-4">
      <div>
        <label class="block text-sm font-medium">Приглашение по ссылке</label>
        <input id="invite-link" type="text" readonly="readonly" class="w-full bg-gray-700 p-2 rounded text-sm sm:text-sm">
        <button id="generate-link" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 mt-2 w-full text-sm sm:text-base">Сгенерировать ссылку</button>
      </div>
      <div>
        <label class="block text-sm font-medium">Добавить роль</label>
        <input id="role-input" type="text" placeholder="Введите роль" class="w-full bg-gray-700 p-2 rounded text-sm sm:text-sm">
        <button id="add-role" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 mt-2 w-full text-sm sm:text-base">Добавить</button>
      </div>
      <div>
        <label class="block text-sm font-medium">Назначить роль</label>
        <select id="member-select" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-sm"></select>
        <select id="role-select" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-sm"></select>
        <button id="assign-role" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full text-sm sm:text-base">Назначить</button>
      </div>
      <div>
        <label class="block text-sm font-medium">Тема интерфейса</label>
        <select id="theme-select" class="w-full bg-gray-700 p-2 rounded text-sm sm:text-sm">
          <option value="dark">Тёмная</option>
          <option value="light">Светлая</option>
        </select>
      </div>
    </div>
  </div>

  <!-- Canvas -->
  <div id="canvas-container" style="display: none;" class="flex-1 bg-gray-700 relative"></div>

  <!-- Context Menu -->
  <div id="context-menu" style="display: none;" class="absolute bg-gray-800 text-white rounded shadow-lg p-2 z-10">
    <button id="create-task" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать задачу</button>
    <button id="create-pdf" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать PDF</button>
    <button id="create-note" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать заметку</button>
    <button id="create-comment" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать комментарий</button>
    <button id="create-text" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать текст</button>
    <button id="delete-element" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Удалить</button>
    <button id="export-pdf" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Экспортировать в PDF</button>
  </div>

  <!-- Modals -->
  <div id="task-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать задачу</h3>
      <input id="task-title" type="text" placeholder="Заголовок задачи" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
      <textarea id="task-desc" placeholder="Описание задачи" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <select id="task-status" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm  sm:text-base">
        <option value="К выполнению">К выполнению</option>
        <option value="В процессе">В процессе</option>
        <option value="Завершено">Завершено</option>
      </select>
      <select id="task-role" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <option value="">Выберите роль</option>
      </select>
      <div class="flex justify-end space-x-2">
        <button id="cancel-task" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-task" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <div id="pdf-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать PDF</h3>
      <textarea id="pdf-content" placeholder="Содержимое PDF" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-pdf" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-pdf" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <div id="note-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать заметку</h3>
      <input id="note-title" type="text" placeholder="Заголовок заметки" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
      <textarea id="note-content" placeholder="Содержимое заметки" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-note" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-note" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <div id="comment-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать комментарий</h3>
      <input id="comment-author" type="text" placeholder="Автор" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
      <textarea id="comment-content" placeholder="Текст комментария" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-comment" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-comment" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <div id="text-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать текст</h3>
      <textarea id="text-content" placeholder="Введите текст" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-text" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-text" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <script>
    // Firebase Config
    const firebaseConfig = {
      apiKey: "AIzaSyAdPjUWf2gkcZxOAkQb-3hkjKtuETOVRhc",
      authDomain: "tawn-71d42.firebaseapp.com",
      projectId: "tawn-71d42",
      storageBucket: "tawn-71d42.firebasestorage.app",
      messagingSenderId: "1098831654973",
      appId: "1:1098831654973:web:4bdc2fb530d7acb17afa54",
      measurementId: "G-55XQ2KBXW9"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // DOM Elements
    const authPanel = document.getElementById('auth-panel');
    const boardPanel = document.getElementById('board-panel');
    const sidebar = document.getElementById('sidebar');
    const canvasContainer = document.getElementById('canvas-container');
    const rolesList = document.getElementById('roles-list');
    const contextMenu = document.getElementById('context-menu');

    // State
    let currentUser = null;
    let currentBoardId = null;
    let isAdmin = false;
    let userRole = null;
    let boardRoles = {};
    let canvases = {};
    let currentCanvas = 'Common';
    let stage, backgroundLayer, transformerLayer, transformer;

    // Debounce Utility
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Update Grid Function
    function updateGrid(stage, backgroundLayer) {
      const now = Date.now();
      if (now - lastGridUpdate < 100) return;
      lastGridUpdate = now;

      try {
        backgroundLayer.destroyChildren();
        const scale = stage.scaleX();
        if (scale < 0.5) return;
        const stagePos = stage.position();
        const visibleWidth = stage.width() / scale;
        const visibleHeight = stage.height() / scale;
        const gridSpacing = 50;
        const startX = Math.floor((-stagePos.x / scale - visibleWidth / 2) / gridSpacing) * gridSpacing;
        const startY = Math.floor((-stagePos.y / scale - visibleHeight / 2) / gridSpacing) * gridSpacing;
        const endX = startX + visibleWidth;
        const endY = startY + visibleHeight;

        for (let y = startY; y < endY; y += gridSpacing) {
          backgroundLayer.add(new Konva.Line({
            points: [startX, y, endX, y],
            stroke: 'rgba(255, 255, 255, 0.2)',
            strokeWidth: 1 / scale,
          }));
        }
        for (let x = startX; x < endX; x += gridSpacing) {
          backgroundLayer.add(new Konva.Line({
            points: [x, startY, x, endY],
            stroke: 'rgba(255, 255, 255, 0.2)',
            strokeWidth: 1 / scale,
          }));
        }
        backgroundLayer.batchDraw();
      } catch (error) {
        console.error('Error updating grid:', error);
      }
    }

    // Authentication
    auth.onAuthStateChanged(user => {
      try {
        if (user) {
          currentUser = user;
          authPanel.style.display = 'none';
          boardPanel.style.display = 'flex';
          document.getElementById('comment-author').value = user.displayName || user.email;
          console.log('User authenticated:', user.displayName || user.email);
          const boardId = window.location.pathname.match(/\/join\/(.+)/)?.[1];
          if (boardId) {
            document.getElementById('join-link').value = `${window.location.origin}/join/${boardId}`;
            boardPanel.style.display = 'flex';
            history.replaceState(null, '', '/');
          }
        } else {
          currentUser = null;
          authPanel.style.display = 'flex';
          boardPanel.style.display = 'none';
          sidebar.style.display = 'none';
          canvasContainer.style.display = 'none';
          console.log('User not authenticated');
        }
      } catch (error) {
        console.error('Error handling auth state:', error);
      }
    });

    // Login
    document.getElementById('login-btn').addEventListener('click', async () => {
      try {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        if (!email || !password) {
          alert('Please enter a valid email and password');
          return;
        }
        await auth.signInWithEmailAndPassword(email, password);
        console.log('Logged in:', email);
      } catch (err) {
        console.error('Login error:', err);
        alert(err.message);
      }
    });

    // Register
    document.getElementById('register-btn').addEventListener('click', async () => {
      try {
        const displayName = document.getElementById('display-name').value.trim();
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        if (!email || !password || !displayName) {
          alert('Please fill in all fields');
          return;
        }
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        await userCredential.user.updateProfile({ displayName });
        console.log('Registered:', displayName || email);
      } catch (err) {
        console.error('Registration error:', err);
        alert(err.message);
      }
    });

    // Google Login
    document.getElementById('google-login-btn').addEventListener('click', async () => {
      try {
        const provider = new firebase.auth.GoogleAuthProvider();
        const result = await auth.signInWithPopup(provider);
        console.log('Google login:', result.user.displayName || result.user.email);
      } catch (err) {
        console.error('Google login error:', err);
        alert(err.message);
      }
    });

    // Logout
    document35.getElementById('logout-btn').addEventListener('click', async () => {
      try {
        await auth.signOut();
        console.log('Logged out');
      } catch (err) {
        console.error('Logout error:', err);
      }
    });

    // Create Board
    document.getElementById('create-board-btn').addEventListener('click', async () => {
      try {
        const boardName = prompt('Enter board name:');
        if (!boardName) return;

        const boardRef = await db.collection('boards').add({
          name: boardName,
          inviteLink: '',
          roles: { 'Common': { Vatikan { readOnly: false }, 'User': { readOnly: false } },
          members: { [currentUser.uid]: { role: 'User', displayName: currentUser.displayName || currentUser.email } }
        });

        const boardId = boardRef.id;
        const inviteLink = `${window.location.origin}/join/${boardId}`;
        await boardRef.update({ inviteLink });

        currentBoardId = boardId;
        isAdmin = false;
        userRole = 'User';
        boardRoles = { 'Common': { readOnly: false }, 'User': { readOnly: false } };

        boardPanel.style.display = 'none';
        sidebar.style.display = 'flex';
        canvasContainer.style.display = 'flex';
        initBoard();
        console.log('Board created:', boardId);
      } catch (error) {
        console.error('Error creating board:', error);
        alert('Error creating board');
      }
    });

    // Join Board
    document.getElementById('join-board-btn').addEventListener('click', async () => {
      try {
        const link = document.getElementById('join-link').value.trim();
        const boardId = link.split('/join/')[1];
        if (!boardId) {
          alert('Invalid link');
          return;
        }

        const boardDoc = await db.collection('boards').doc(boardId).get();
        if (!boardDoc.exists) {
          alert('Board not found');
          return;
        }

        const boardData = boardDoc.data();
        await db.collection('boards').doc(boardId).update({
          [`members.${currentUser.uid}`]: { role: 'User', displayName: currentUser.displayName || currentUser.email }
        });

        currentBoardId = boardId;
        isAdmin = false;
        userRole = 'User';
        boardRoles = boardData.roles;

        boardPanel.style.display = 'none';
        sidebar.style.display = 'flex';
        canvasContainer.style.display = 'flex';
        initBoard();
        console.log('Joined board:', boardId, 'User:', currentUser.displayName || currentUser.email);
      } catch (error) {
        console.error('Error joining board:', error);
        alert('Error joining board');
      }
    });

    // Export Boards
    document.getElementById('export-boards-btn').addEventListener('click', async () => {
      try {
        const boardsSnapshot = await db.collection('boards')
          .where(`members.${currentUser.uid}`, '!=', null)
          .get();
        const boardsData = [];
        for (const boardDoc of boardsSnapshot.docs) {
          const boardId = boardDoc.id;
          const boardData = boardDoc.data();
          const elementsSnapshot = await db.collection(`boards/${boardId}/elements`).get();
          const elements = elementsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
          boardsData.push({ id: boardId, ...boardData, elements });
        }
        const blob = new Blob([JSON.stringify(boardsData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'boards_export.json';
        a.click();
        URL.revokeObjectURL(url);
        console.log('Boards exported');
      } catch (error) {
        console.error('Error exporting boards:', error);
        alert('Error exporting boards');
      }
    });

    // Import Boards
    document.getElementById('import-boards').addEventListener('change', async (e) => {
      try {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = async (event) => {
          const boardsData = JSON.parse(event.target.result);
          for (const board of boardsData) {
            const { id, elements, ...boardData } = board;
            const boardRef = await db.collection('boards').add({
              ...boardData,
              members: { [currentUser.uid]: { role: 'User', displayName: currentUser.displayName || currentUser.email } }
            });
            for (const element of elements) {
              await db.collection(`boards/${boardRef.id}/elements`).add(element);
            }
            console.log('Imported board:', boardRef.id);
          }
          alert('Boards imported');
        };
        reader.readAsText(file);
      } catch (error) {
        console.error('Error importing boards:', error);
        alert('Error importing boards');
      }
    });

    // Initialize Board
    function initBoard() {
      try {
        stage = new Konva.Stage({
          container: 'canvas-container',
          width: window.innerWidth - (window.innerWidth < 768 ? 0 : 256),
          height: window.innerHeight
        });

        backgroundLayer = new Konva.Layer({ listening: false });
        stage.add(backgroundLayer);
        updateGrid(stage, backgroundLayer);

        transformerLayer = new Konva.Layer();
        transformer = new Konva.Transformer({
          nodes: [],
          keepRatio: false,
          enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
          boundBoxFunc: (oldBox, newBox) => ({
            width: newBox.width >= 50 ? newBox.width : oldBox.width,
            height: newBox.height >= 50 ? newBox.height : oldBox.height
          })
        });
        transformerLayer.add(transformer);
        stage.add(transformerLayer);

        canvases = { 'Common': new Konva.Layer() };
        Object.keys(boardRoles).forEach(role => {
          if (role !== 'Common') canvases[role] = new Konva.Layer();
        });
        stage.add(canvases[currentCanvas]);

        loadVisibleElements();
        updateRolesList();
        setupEventListeners();
        console.log('Board initialized');
      } catch (err) {
        console.error('Error initializing board:', err);
      }
    }

    // Load Visible Elements
    async function loadVisibleElements() {
      try {
        const scale = stage.scaleX();
        const pos = stage.position();
        const width = stage.width() / scale;
        const height = stage.height() / scale;
        const xMin = -pos.x / scale - width / 2;
        const xMax = xMin + width;
        const yMin = -pos.y / scale - height / 2;
        const yMax = yMin + height;

        // Fetch all elements and filter client-side due to Firestore query limitations
        const snapshot = await db.collection(`boards/${currentBoardId}/elements`).get();
        snapshot.forEach(doc => {
          const data = doc.data();
          const elementId = doc.id;
          const role = data.role || 'Common';
          if (!canvases[role]) return;

          // Client-side filtering for visibility
          if (data.x >= xMin && data.x <= xMax && data.y >= yMin && data.y <= yMax) {
            const existing = canvases[role].findOne(`#${elementId}`);
            if (existing) return;

            const group = createElementFromData(data, elementId);
            group.id(elementId);
            canvases[role].add(group);
          }
        });

        stage.batchDraw();
      } catch (error) {
        console.error('Error loading visible elements:', error);
      }
    }

    // Create Element from Data
    function createElementFromData(data, elementId) {
      const group = new Konva.Group({
        x: data.x,
        y: data.y,
        width: data.width,
        height: data.height,
        draggable: isEditable(data.role),
        name: data.type
      });

      const bg = new Konva.Rect({
        width: data.width,
        height: data.height,
        fill: data.bgFill || '#ffffff',
        stroke: '#d1d5db',
        strokeWidth: 2,
        cornerRadius: 4,
        shadowColor: 'rgba(0,0,0,0.1)',
        shadowBlur: 5
      });

      group.add(bg);

      if (data.type === 'task') {
        const titleText = new Konva.Text({
          x: 8,
          y: 8,
          text: data.title,
          fontSize: 12,
          fontFamily: 'Arial',
          fontStyle: 'bold',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        const descText = new Konva.Text({
          x: 8,
          y: 32,
          text: data.desc,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        const statusText = new Konva.Text({
          x: 8,
          y: data.height - 24,
          text: `Status: ${data.status}`,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: data.status === 'Завершено' ? '#22c55e' : data.status === 'В процессе' ? '#f59e0b' : '#ef4444',
          width: data.width - 16,
          padding: 4
        });

        group.add(titleText, descText, statusText);
      } else if (data.type === 'pdf') {
        const text = new Konva.Text({
          x: 8,
          y: 8,
          text: data.content,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });
        group.add(text);
      } else if (data.type === 'note') {
        const titleText = new Konva.Text({
          x: 8,
          y: 8,
          text: data.title,
          fontSize: 12,
          fontFamily: 'Arial',
          fontStyle: 'bold',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        const contentText = new Konva.Text({
          x: 8,
          y: 32,
          text: data.content,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        group.add(titleText, contentText);
      } else if (data.type === 'comment') {
        const authorText = new Konva.Text({
          x: 8,
          y: 8,
          text: `From: ${data.author} (${data.date})`,
          fontSize: 10,
          fontFamily: 'Arial',
          fontStyle: 'italic',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        const contentText = new Konva.Text({
          x: 8,
          y: 32,
          text: data.content,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        group.add(authorText, contentText);
      } else if (data.type === 'text') {
        const contentText = new Konva.Text({
          x: 8,
          y: 8,
          text: data.content,
          fontSize: 12,
          fontFamily: 'Arial',
          fill: 'white',
          width: data.width - 16,
          padding: 4
        });
        group.add(contentText);
      }

      if (isEditable(data.role)) {
        group.on('dblclick', () => editElement(group, data.type));
        group.on('dragend', () => updateElementData(group, elementId));
        group.on('transformend', () => updateElementSize(group, elementId));
      }

      return group;
    }

    // Check if Role is Editable
    function isEditable(role) {
      return role === 'Common' || role === userRole;
    }

    // Update Roles List
    function updateRolesList() {
      try {
        rolesList.innerHTML = '';
        const allRoles = ['Common', ...Object.keys(boardRoles)];
        allRoles.forEach(role => {
          const li = document.createElement('li');
          li.className = `p-2 rounded cursor-pointer transition bg-gray-700 hover:bg-gray-600 ${role === currentCanvas ? 'bg-blue-600' : ''} fade-in`;
          li.textContent = role;
          li.addEventListener('click', () => {
            if (!canvases[role]) {
              canvases[role] = new Konva.Layer();
              loadVisibleElements();
            }
            currentCanvas = role;
            stage.getLayers().forEach(layer => {
              if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
            });
            stage.add(canvases[role]);
            stage.batchDraw();
            updateRolesList();
            console.log(`Switched to canvas: ${role}`);
          });
          rolesList.appendChild(li);
        });
        updateTaskRoleSelect();
        updateAdminPanel();
      } catch (error) {
        console.error('Error updating roles list:', error);
      }
    }

    // Update Task Role Select
    function updateTaskRoleSelect() {
      try {
        const taskRoleSelect = document.getElementById('task-role');
        taskRoleSelect.innerHTML = '<option value="">Select role</option>';
        ['Common', userRole].forEach(role => {
          if (role) {
            const option = document.createElement('option');
            option.value = role;
            option.textContent = role;
            taskRoleSelect.appendChild(option);
          }
        });
      } catch (error) {
        console.error('Error updating task role select:', error);
      }
    }

    // Update Admin Panel
    async function updateAdminPanel() {
      try {
        document.getElementById('toggle-admin').style.display = 'none';
        document.getElementById('invite-link').value = `${window.location.origin}/join/${currentBoardId}`;
      } catch (error) {
        console.error('Error updating admin panel:', error);
      }
    }

    // Setup Event Listeners
    function setupEventListeners() {
      try {
        // Admin Panel Toggle
        document.getElementById('toggle-admin').addEventListener('click', () => {
          const adminPanel = document.getElementById('admin-panel');
          adminPanel.style.display = adminPanel.style.display === 'none' ? 'block' : 'none';
          adminPanel.classList.toggle('slide-in', adminPanel.style.display === 'block');
        });

        // Generate Invite Link
        document.getElementById('generate-link').addEventListener('click', async () => {
          document.getElementById('invite-link').value = `${window.location.origin}/join/${currentBoardId}`;
          console.log('Invite link updated');
        });

        // Add Role
        document.getElementById('add-role').addEventListener('click', async () => {
          try {
            const roleInput = document.getElementById('role-input');
            const role = roleInput.value.trim();
            if (role && !boardRoles[role]) {
              boardRoles[role] = { readOnly: false };
              await db.collection('boards').doc(currentBoardId).update({
                roles: boardRoles
              });
              updateRolesList();
              roleInput.value = '';
              console.log('Added role:', role);
            }
          } catch (error) {
            console.error('Error adding role:', error);
          }
        });

        // Assign Role
        document.getElementById('assign-role').addEventListener('click', async () => {
          try {
            const uid = document.getElementById('member-select').value;
            const role = document.getElementById('role-select').value;
            await db.collection('boards').doc(currentBoardId).update({
              [`members.${uid}.role`]: role
            });
            console.log(`Assigned role ${role} to user ${uid}`);
          } catch (error) {
            console.error('Error assigning role:', error);
          }
        });

        // Theme Switch
        document.getElementById('theme-select').addEventListener('change', (e) => {
          document.body.className = e.target.value === 'light' ? 'min-h-screen bg-gray-100 text-black light' : 'min-h-screen bg-gray-900 text-white';
          console.log('Theme switched:', e.target.value);
        });

        // Context Menu
        let contextTarget = null;
        let contextPos = { x: 0, y: 0 };
        let longPressTimer = null;
        const showContextMenu = (x, y, intersection) => {
          contextPos.x = x;
          contextPos.y = y;
          contextTarget = intersection ? getGroupAncestor(intersection) : null;

          const menuItems = ['create-task', 'create-pdf', 'create-note', 'create-comment', 'create-text', 'delete-element', 'export-pdf'];
          menuItems.forEach(item => document.getElementById(item).style.display = 'none');

          if (contextTarget && isEditable(contextTarget.attrs.role)) {
            document.getElementById('delete-element').style.display = 'block';
            if (contextTarget.hasName('pdf')) {
              document.getElementById('export-pdf').style.display = 'block';
            }
          } else if (isEditable(currentCanvas)) {
            ['create-task', 'create-pdf', 'create-note', 'create-comment', 'create-text'].forEach(id => {
              document.getElementById(id).style.display = 'block';
            });
          }

          contextMenu.style.left = `${x}px`;
          contextMenu.style.top = `${y}px`;
          contextMenu.style.display = 'block';
        };

        stage.on('contextmenu', (e) => {
          e.evt.preventDefault();
          const pos = stage.getPointerPosition();
          const intersection = stage.getIntersection(pos);
          showContextMenu(e.evt.clientX, e.evt.clientY, intersection);
        });

        // Mobile Long Press
        stage.on('touchstart', (e) => {
          const pos = stage.getPointerPosition();
          const intersection = stage.getIntersection(pos);
          longPressTimer = setTimeout(() => {
            showContextMenu(pos.x, pos.y, intersection);
          }, 500);
        });

        stage.on('touchend touchmove', () => {
          if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
          }
        });

        document.addEventListener('click', (e) => {
          if (!contextMenu.contains(e.target)) {
            contextMenu.style.display = 'none';
            contextTarget = null;
          }
        });

        // Transformer Click
        stage.on('mousedown touchstart', (e) => {
          const pos = stage.getPointerPosition();
          const intersection = stage.getIntersection(pos);
          if (!intersection || intersection.getLayer() === backgroundLayer) {
            transformer.nodes([]);
          } else {
            const group = getGroupAncestor(intersection);
            if (group && isEditable(group.attrs.role)) {
              transformer.nodes([group]);
            } else {
              transformer.nodes([]);
            }
          }
          stage.batchDraw();
        });

        // Create Task
        document.getElementById('create-task').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('task-modal').style.display = 'flex';
          document.getElementById('task-title').value = '';
          document.getElementById('task-desc').value = '';
        });

        // Cancel Task
        document.getElementById('cancel-task').addEventListener('click', () => {
          document.getElementById('task-modal').style.display = 'none';
          document.getElementById('task-title').value = '';
          document.getElementById('task-desc').value = '';
        });

        // Save Task
        let editingTask = null;
        document.getElementById('save-task').addEventListener('click', async () => {
          try {
            const title = document.getElementById('task-title').value.trim();
            const desc = document.getElementById('task-desc').value.trim();
            const status = document.getElementById('task-status').value;
            const role = document.getElementById('task-role').value || currentCanvas;

            if (!title || !desc) {
              alert('Please fill in title and description');
              return;
            }

            if (!isEditable(role)) {
              alert('No edit permissions');
              return;
            }

            const taskData = {
              type: 'task',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              title,
              desc,
              status,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(taskData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(taskData);
            }

            document.getElementById('task-modal').style.display = 'none';
            document.getElementById('task-title').value = '';
            document.getElementById('task-desc').value = '';
          } catch (error) {
            console.error('Error saving task:', error);
          }
        });

        // Create PDF
        document.getElementById('create-pdf').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('pdf-modal').style.display = 'flex';
          document.getElementById('pdf-content').value = '';
        });

        // Cancel PDF
        document.getElementById('cancel-pdf').addEventListener('click', () => {
          document.getElementById('pdf-modal').style.display = 'none';
          document.getElementById('pdf-content').value = '';
        });

        // Save PDF
        document.getElementById('save-pdf').addEventListener('click', async () => {
          try {
            const content = document.getElementById('pdf-content').value.trim();
            const role = currentCanvas;

            if (!content) {
              alert('Please fill in content');
              return;
            }

            if (!isEditable(role)) {
              alert('No edit permissions');
              return;
            }

            const pdfData = {
              type: 'pdf',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              content,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(pdfData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(pdfData);
            }

            document.getElementById('pdf-modal').style.display = 'none';
            document.getElementById('pdf-content').value = '';
          } catch (error) {
            console.error('Error saving PDF:', error);
          }
        });

        // Create Note
        document.getElementById('create-note').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('note-modal').style.display = 'flex';
          document.getElementById('note-title').value = '';
          document.getElementById('note-content').value = '';
        });

        // Cancel Note
        document.getElementById('cancel-note').addEventListener('click', () => {
          document.getElementById('note-modal').style.display = 'none';
          document.getElementById('note-title').value = '';
          document.getElementById('note-content').value = '';
        });

        // Save Note
        document.getElementById('save-note').addEventListener('click', async () => {
          try {
            const title = document.getElementById('note-title').value.trim();
            const content = document.getElementById('note-content').value.trim();
            const role = currentCanvas;

            if (!title || !content) {
              alert('Please fill in title and content');
              return;
            }

            if (!isEditable(role)) {
              alert('No edit permissions');
              return;
            }

            const noteData = {
              type: 'note',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              title,
              content,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(noteData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(noteData);
            }

            document.getElementById('note-modal').style.display = 'none';
            document.getElementById('note-title').value = '';
            document.getElementById('note-content').value = '';
          } catch (error) {
            console.error('Error saving note:', error);
          }
        });

        // Create Comment
        document.getElementById('create-comment').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('comment-modal').style.display = 'flex';
          document.getElementById('comment-author').value = currentUser.displayName || currentUser.email;
          document.getElementById('comment-content').value = '';
        });

        // Cancel Comment
        document.getElementById('cancel-comment').addEventListener('click', () => {
          document.getElementById('comment-modal').style.display = 'none';
          document.getElementById('comment-content').value = '';
        });

        // Save Comment
        document.getElementById('save-comment').addEventListener('click', async () => {
          try {
            const author = document.getElementById('comment-author').value.trim();
            const content = document.getElementById('comment-content').value.trim();
            const role = currentCanvas;
            const date = new Date().toLocaleDateString();

            if (!author || !content) {
              alert('Please fill in author and content');
              return;
            }

            if (!isEditable(role)) {
              alert('No edit permissions');
              return;
            }

            const commentData = {
              type: 'comment',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              author,
              content,
              date,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(commentData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(commentData);
            }

            document.getElementById('comment-modal').style.display = 'none';
            document.getElementById('comment-content').value = '';
          } catch (error) {
            console.error('Error saving comment:', error);
          }
        });

        // Create Text
        document.getElementById('create-text').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('text-modal').style.display = 'flex';
          document.getElementById('text-content').value = '';
        });

        // Cancel Text
        document.getElementById('cancel-text').addEventListener('click', () => {
          document.getElementById('text-modal').style.display = 'none';
          document.getElementById('text-content').value = '';
        });

        // Save Text
        document.getElementById('save-text').addEventListener('click', async () => {
          try {
            const content = document.getElementById('text-content').value.trim();
            const role = currentCanvas;

            if (!content) {
              alert('Please fill in content');
              return;
            }

            if (!isEditable(role)) {
              alert('No edit permissions');
              return;
            }

            const textData = {
              type: 'text',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              content,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(textData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(textData);
            }

            document.getElementById('text-modal').style.display = 'none';
            document.getElementById('text-content').value = '';
          } catch (error) {
            console.error('Error saving text:', error);
          }
        });

        // Delete Element
        document.getElementById('delete-element').addEventListener('click', async () => {
          try {
            if (contextTarget && isEditable(contextTarget.attrs.role)) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(contextTarget.id()).delete();
              contextMenu.style.display = 'none';
              contextTarget = null;
            }
          } catch (error) {
            console.error('Error deleting element:', error);
          }
        });

        // Export PDF
        document.getElementById('export-pdf').addEventListener('click', () => {
          try {
            if (contextTarget && contextTarget.hasName('pdf')) {
              const { jsPDF } = window.jspdf;
              const doc = new jsPDF();
              const content = contextTarget.find('Text')[0].text();
              doc.text(content, 10, 10);
              doc.save('exported.pdf');
              contextMenu.style.display = 'none';
              console.log('PDF exported');
            }
          } catch (error) {
            console.error('Error exporting PDF:', error);
          }
        });

        // Zoom and Pan
        let scale = 1;
        const zoomHandler = debounce((e) => {
          e.evt.preventDefault();
          const oldScale = scale;
          const pointer = stage.getPointerPosition();
          const mousePointTo = {
            x: pointer.x / oldScale - stage.x() / oldScale,
            y: pointer.y / oldScale - stage.y() / oldScale
          };

          const deltaY = e.evt.deltaY;
          scale *= (deltaY > 0 ? 0.9 : 1.1);
          scale = Math.max(0.3, Math.min(scale, 4));

          stage.scale({ x: scale, y: scale });
          const newPos = {
            x: -(mousePointTo.x - pointer.x / scale) * scale,
            y: -(mousePointTo.y - pointer.y / scale) * scale
          };
          stage.position(newPos);
          updateGrid(stage, backgroundLayer);
          loadVisibleElements();
          stage.batchDraw();
        }, 100);

        stage.on('wheel', zoomHandler);

        // Touch Zoom and Pan
        let lastDist = 0;
        let startPos = null;
        stage.on('touchstart', (e) => {
          if (e.evt.touches.length === 2) {
            const touch1 = e.evt.touches[0];
            const touch2 = e.evt.touches[1];
            lastDist = Math.sqrt((touch1.clientX - touch2.clientX) ** 2 + (touch1.clientY - touch2.clientY) ** 2);
            startPos = stage.position();
          }
        });

        stage.on('touchmove', (e) => {
          if (e.evt.touches.length === 2) {
            e.evt.preventDefault();
            const touch1 = e.evt.touches[0];
            const touch2 = e.evt.touches[1];
            const dist = Math.sqrt((touch1.clientX - touch2.clientX) ** 2 + (touch1.clientY - touch2.clientY) ** 2);
            if (dist > 0) {
              const oldScale = scale;
              scale *= (dist / lastDist);
              scale = Math.max(0.3, Math.min(scale, 4));
              stage.scale({ x: scale, y: scale });
              updateGrid(stage, backgroundLayer);
              loadVisibleElements();
              stage.batchDraw();
              lastDist = dist;
            }
          } else if (e.evt.touches.length === 1 && startPos) {
            const touch = e.evt.touches[0];
            stage.position({
              x: startPos.x + (touch.clientX - startPos.x),
              y: startPos.y + (touch.clientY - startPos.y)
            });
            updateGrid(stage, backgroundLayer);
            loadVisibleElements();
            stage.batchDraw();
          }
        });

        stage.on('touchend', () => {
          lastDist = 0;
          startPos = null;
        });

        // Drag Pan
        let isDragging = false;
        let dragStartPos = { x: 0, y: 0 };
        stage.on('mousedown touchstart', (e) => {
          if (e.evt.ctrlKey && e.evt.button === 0 || e.evt.type === 'touchstart') {
            isDragging = true;
            dragStartPos = stage.getPointerPosition();
          }
        });

        stage.on('mousemove touchmove', (e) => {
          if (isDragging) {
            const pos = stage.getPointerPosition();
            const dx = pos.x - dragStartPos.x;
            const dy = pos.y - dragStartPos.y;
            stage.position({
              x: stage.x() + dx,
              y: stage.y() + dy
            });
            updateGrid(stage, backgroundLayer);
            loadVisibleElements();
            stage.batchDraw();
            dragStartPos = pos;
          }
        });

        stage.on('mouseup touchend', () => {
          isDragging = false;
        });

        // Resize Window
        window.addEventListener('resize', () => {
          stage.width(window.innerWidth - (window.innerWidth < 768 ? 0 : 256));
          stage.height(window.innerHeight);
          updateGrid(stage, backgroundLayer);
          stage.batchDraw();
        });
      } catch (error) {
        console.error('Error setting up event listeners:', error);
      }
    }

    // Get Group Ancestor
    function getGroupAncestor(node) {
      let currentNode = node;
      while (currentNode && currentNode.getType() !== 'Stage') {
        if (currentNode.hasName('task') || currentNode.hasName('pdf') || currentNode.hasName('note') || currentNode.hasName('comment') || currentNode.hasName('text')) {
          return currentNode;
        }
        currentNode = currentNode.getParent();
      }
      return null;
    }

    // Edit Element
    function editElement(group, type) {
      if (!isEditable(group.attrs.role)) return;

      if (type === 'task') {
        editingTask = group;
        document.getElementById('task-modal').style.display = 'flex';
        document.getElementById('task-title').value = group.find('Text')[0].text();
        document.getElementById('task-desc').value = group.find('Text')[1].text();
        document.getElementById('task-status').value = group.find('Text')[2].text().replace('Status: ', '');
      } else if (type === 'pdf') {
        editingTask = group;
        document.getElementById('pdf-modal').style.display = 'flex';
        document.getElementById('pdf-content').value = group.find('Text')[0].text();
      } else if (type === 'note') {
        editingTask = group;
        document.getElementById('note-modal').style.display = 'flex';
        document.getElementById('note-title').value = group.find('Text')[0].text();
        document.getElementById('note-content').value = group.find('Text')[1].text();
      } else if (type === 'comment') {
        editingTask = group;
        document.getElementById('comment-modal').style.display = 'flex';
        document.getElementById('comment-author').value = group.find('Text')[0].text().split(' ')[1];
        document.getElementById('comment-content').value = group.find('Text')[1].text();
      } else if (type === 'text') {
        editingTask = group;
        document.getElementById('text-modal').style.display = 'flex';
        document.getElementById('text-content').value = group.find('Text')[0].text();
      }
    }

    // Update Element Size
    async function updateElementSize(group, elementId) {
      try {
        const newWidth = group.width() * group.scaleX();
        const newHeight = group.height() * group.scaleY();
        group.setAttrs({
          width: newWidth,
          height: newHeight,
          scaleX: 1,
          scaleY: 1
        });

        const bg = group.find('Rect')[0];
        bg.setAttrs({ width: newWidth, height: newHeight });

        const texts = group.find('Text');
        texts.forEach((text, i) => {
          text.width(newWidth - 16);
          if (group.hasName('task') && i === 2) {
            text.y(newHeight - 24);
          }
        });

        await db.collection(`boards/${currentBoardId}/elements`).doc(elementId).update({
          width: newWidth,
          height: newHeight
        });

        stage.batchDraw();
        console.log(`${group.name()} resized: width=${newWidth}, height=${newHeight}`);
      } catch (error) {
        console.error('Error updating size:', error);
      }
    }

    // Update Element Data
    async function updateElementData(group, elementId) {
      try {
        await db.collection(`boards/${currentBoardId}/elements`).doc(elementId).update({
          x: group.x(),
          y: group.y()
        });
        stage.batchDraw();
        console.log(`Element ${elementId} moved`);
      } catch (error) {
        console.error('Error updating position:', error);
      }
    }
  </script>
</body>
</html>