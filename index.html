<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Доска управления задачами</title>
  <link rel="icon" href="data:,">
  <script src="https://unpkg.com/konva@8.3.5/konva.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  <style>
    @keyframes slide-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes fade-in {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .slide-in { animation: slide-in 0.3s ease-out; }
    .fade-in { animation: fade-in 0.3s ease-out; }
    .card-hover:hover { transform: scale(1.02); transition: transform 0.2s ease; }
    #admin-panel, #auth-panel, #board-panel { z-index: 1000; }
    #canvas-container { position: relative; overflow: hidden; width: 100%; height: calc(100vh - 48px); }
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center; }
    .modal-content { background: #1a202c; padding: 4px; border-radius: 8px; width: 90%; max-width: 400px; }
    @media (max-width: 600px) {
      #sidebar { width: 100%; position: fixed; top: 0; left: 0; z-index: 1500; }
      #canvas-container { width: 100%; height: calc(100vh - 48px); }
      .modal-content { width: 95%; padding: 10px; }
      #admin-panel { width: 100%; height: 100%; position: fixed; top: 0; right: 0; }
    }
  </style>
</head>
<body class="min-h-screen bg-gray-900 text-white overflow-hidden">
  <!-- Панель авторизации -->
  <div id="auth-panel" class="flex flex-col items-center justify-center min-h-screen w-full bg-gray-800 p-4">
    <div class="text-center mb-6">
      <h2 class="text-2xl font-bold sm:text-3xl">Вход или регистрация</h2>
    </div>
    <div class="bg-gray-800 p-4 rounded-lg w-full max-w-md">
      <div id="email-auth">
        <input id="display-name" type="text" placeholder="Ваше имя" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <input id="email" type="email" placeholder="Email" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <input id="password" type="password" placeholder="Пароль" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <button id="login-btn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full mb-2 text-sm sm:text-base">Войти</button>
        <button id="register-btn" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 w-full text-sm sm:text-base">Зарегистрироваться</button>
      </div>
      <div class="mt-4 text-center">
        <button id="google-login-btn" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 w-full text-sm sm:text-base">Войти через Google</button>
      </div>
    </div>
  </div>

  <!-- Панель выбора доски -->
  <div id="board-panel" style="display: none;" class="flex flex-col items-center justify-center min-h-screen w-full bg-gray-800 p-4">
    <div class="bg-gray-800 p-4 rounded-lg w-full max-w-md">
      <h3 class="text-lg font-bold mb-4 sm:text-xl">Выберите действие</h3>
      <button id="create-board-btn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full mb-2 text-sm sm:text-base">Создать новую доску</button>
      <input id="join-link" type="text" placeholder="Вставьте ссылку-приглашение" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
      <button id="join-board-btn" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 w-full text-sm sm:text-base">Присоединиться к доске</button>
    </div>
  </div>

  <!-- Боковая панель -->
  <div id="sidebar" style="display: none;" class="w-full bg-gray-800 p-4 flex flex-col sm:w-64 min-h-screen slide-in">
    <h2 class="text-lg font-semibold mb-4 sm:text-xl">Холсты</h2>
    <ul id="roles-list" class="space-y-2"></ul>
    <button id="toggle-admin" class="mt-auto bg-blue-600 text-white px-4 py-2 hover:bg-blue-700 transition text-sm sm:text-base">Админ-панель</button>
    <button id="logout-btn" class="mt-2 bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition text-sm sm:text-base">Выйти</button>
  </div>

  <!-- Админ-панель -->
  <div id="admin-panel" style="display: none;" class="w-full bg-gray-800 p-4 absolute right-0 top-0 h-full sm:w-80 sm:h-full slide-in">
    <h2 class="text-lg font-semibold mb-4 sm:text-xl">Админ-панель</h2>
    <div class="space-y-4">
      <div>
        <label class="block text-sm font-medium">Приглашение по ссылке</label>
        <input id="invite-link" type="text" readonly="readonly" class="w-full bg-gray-700 p-2 rounded text-sm sm:text-sm">
        <button id="generate-link" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 mt-2 w-full text-sm sm:text-base">Сгенерировать ссылку</button>
      </div>
      <div>
        <label class="block text-sm font-medium">Добавить роль</label>
        <input id="role-input" type="text" placeholder="Введите роль" class="w-full bg-gray-700 p-2 rounded text-sm sm:text-sm">
        <button id="add-role" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 mt-2 w-full text-sm sm:text-base">Добавить</button>
      </div>
      <div>
        <label class="block text-sm font-medium">Назначить роль</label>
        <select id="member-select" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-sm"></select>
        <select id="role-select" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-sm"></select>
        <button id="assign-role" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full text-sm sm:text-base">Назначить</button>
      </div>
    </div>
  </div>

  <!-- Холст -->
  <div id="canvas-container" style="display: none;" class="flex-1 bg-gray-700 relative"></div>

  <!-- Контекстное меню -->
  <div id="context-menu" style="display: none;" class="absolute bg-gray-800 text-white rounded shadow-lg p-2 z-10">
    <button id="create-task" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать задачу</button>
    <button id="create-pdf" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать PDF</button>
    <button id="create-note" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать заметку</button>
    <button id="create-comment" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать комментарий</button>
    <button id="create-text" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Создать текст</button>
    <button id="delete-element" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Удалить</button>
    <button id="export-pdf" class="block px-4 py-2 hover:bg-gray-600 w-full text-left text-sm sm:text-base">Экспортировать в PDF</button>
  </div>

  <!-- Модальные окна -->
  <div id="task-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать задачу</h3>
      <input id="task-title" type="text" placeholder="Заголовок задачи" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
      <textarea id="task-desc" placeholder="Описание задачи" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <select id="task-status" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <option value="К выполнению">К выполнению</option>
        <option value="В процессе">В процессе</option>
        <option value="Завершено">Завершено</option>
      </select>
      <select id="task-role" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
        <option value="">Выберите роль</option>
      </select>
      <div class="flex justify-end space-x-2">
        <button id="cancel-task" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-task" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <div id="pdf-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать PDF</h3>
      <textarea id="pdf-content" placeholder="Содержимое PDF" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-pdf" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-pdf" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <div id="note-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать заметку</h3>
      <input id="note-title" type="text" placeholder="Заголовок заметки" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
      <textarea id="note-content" placeholder="Содержимое заметки" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-note" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-note" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <div id="comment-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать комментарий</h3>
      <input id="comment-author" type="text" placeholder="Автор" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base">
      <textarea id="comment-content" placeholder="Текст комментария" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-comment" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-comment" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <div id="text-modal" class="modal-overlay">
    <div class="modal-content">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать текст</h3>
      <textarea id="text-content" placeholder="Введите текст" class="w-full bg-gray-700 p-2 rounded mb-2 text-sm sm:text-base"></textarea>
      <div class="flex justify-end space-x-2">
        <button id="cancel-text" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm sm:text-base">Отмена</button>
        <button id="save-text" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm sm:text-base">Сохранить</button>
      </div>
    </div>
  </div>

  <script>
    // Конфигурация Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyAdPjUWf2gkcZxOAkQb-3hkjKtuETOVRhc",
      authDomain: "tawn-71d42.firebaseapp.com",
      projectId: "tawn-71d42",
      storageBucket: "tawn-71d42.firebasestorage.app",
      messagingSenderId: "1098831654973",
      appId: "1:1098831654973:web:4bdc2fb530d7acb17afa54",
      measurementId: "G-55XQ2KBXW9"
    };

    // Инициализация Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // Элементы DOM
    const authPanel = document.getElementById('auth-panel');
    const boardPanel = document.getElementById('board-panel');
    const sidebar = document.getElementById('sidebar');
    const canvasContainer = document.getElementById('canvas-container');
    const rolesList = document.getElementById('roles-list');
    const contextMenu = document.getElementById('context-menu');
    const adminPanel = document.getElementById('admin-panel');
    const toggleAdminBtn = document.getElementById('toggle-admin');

    // Состояние приложения
    let currentUser = null;
    let currentBoardId = null;
    let isAdmin = false;
    let userRole = null;
    let boardRoles = {};
    let canvases = {};
    let currentCanvas = 'Common';
    let stage, backgroundLayer, transformerLayer, transformer;
    let lastGridUpdate = 0;

    // Утилита для предотвращения частых вызовов функций
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Обновление сетки на холсте
    function updateGrid(stage, backgroundLayer) {
      const now = Date.now();
      if (now - lastGridUpdate < 100) return;
      lastGridUpdate = now;

      try {
        backgroundLayer.destroyChildren();
        const scale = stage.scaleX();
        if (scale < 0.5) return;
        const stagePos = stage.position();
        const visibleWidth = stage.width() / scale;
        const visibleHeight = stage.height() / scale;
        const gridSpacing = 50;
        const startX = Math.floor((-stagePos.x / scale - visibleWidth / 2) / gridSpacing) * gridSpacing;
        const startY = Math.floor((-stagePos.y / scale - visibleHeight / 2) / gridSpacing) * gridSpacing;
        const endX = startX + visibleWidth;
        const endY = startY + visibleHeight;

        for (let y = startY; y < endY; y += gridSpacing) {
          backgroundLayer.add(new Konva.Line({
            points: [startX, y, endX, y],
            stroke: 'rgba(255, 255, 255, 0.2)',
            strokeWidth: 1 / scale,
          }));
        }
        for (let x = startX; x < endX; x += gridSpacing) {
          backgroundLayer.add(new Konva.Line({
            points: [x, startY, x, endY],
            stroke: 'rgba(255, 255, 255, 0.2)',
            strokeWidth: 1 / scale,
          }));
        }
        backgroundLayer.batchDraw();
        console.log('Сетка обновлена');
      } catch (error) {
        console.error('Ошибка обновления сетки:', error);
      }
    }

    // Обработка состояния авторизации
    auth.onAuthStateChanged(user => {
      try {
        if (user) {
          currentUser = user;
          authPanel.style.display = 'none';
          boardPanel.style.display = 'flex';
          document.getElementById('comment-author').value = user.displayName || user.email;
          console.log('Пользователь авторизован:', user.displayName || user.email);
          const boardId = window.location.pathname.match(/\/join\/(.+)/)?.[1];
          if (boardId) {
            document.getElementById('join-link').value = `${window.location.origin}/join/${boardId}`;
            boardPanel.style.display = 'flex';
            history.replaceState(null, '', '/');
          }
        } else {
          currentUser = null;
          authPanel.style.display = 'flex';
          boardPanel.style.display = 'none';
          sidebar.style.display = 'none';
          canvasContainer.style.display = 'none';
          console.log('Пользователь не авторизован');
        }
      } catch (error) {
        console.error('Ошибка обработки состояния авторизации:', error);
      }
    });

    // Вход
    document.getElementById('login-btn').addEventListener('click', async () => {
      try {
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        await auth.signInWithEmailAndPassword(email, password);
        console.log('Вход выполнен:', email);
      } catch (err) {
        console.error('Ошибка входа:', err);
        alert(err.message);
      }
    });

    // Регистрация
    document.getElementById('register-btn').addEventListener('click', async () => {
      try {
        const displayName = document.getElementById('display-name').value.trim();
        const email = document.getElementById('email').value;
        const password = document.getElementById('password').value;
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        await userCredential.user.updateProfile({ displayName });
        console.log('Зарегистрирован:', displayName || email);
      } catch (err) {
        console.error('Ошибка регистрации:', err);
        alert(err.message);
      }
    });

    // Вход через Google
    document.getElementById('google-login-btn').addEventListener('click', async () => {
      try {
        const provider = new firebase.auth.GoogleAuthProvider();
        const result = await auth.signInWithPopup(provider);
        console.log('Вход через Google:', result.user.displayName || result.user.email);
      } catch (err) {
        console.error('Ошибка входа через Google:', err);
        alert(err.message);
      }
    });

    // Выход
    document.getElementById('logout-btn').addEventListener('click', async () => {
      try {
        await auth.signOut();
        console.log('Выход выполнен');
      } catch (err) {
        console.error('Ошибка выхода:', err);
      }
    });

    // Создание доски
    document.getElementById('create-board-btn').addEventListener('click', async () => {
      try {
        const boardName = prompt('Введите название доски:');
        if (!boardName) return;

        console.log('Создание доски:', boardName, 'Пользователь:', currentUser.uid);
        const boardRef = await db.collection('boards').add({
          name: boardName,
          inviteLink: '',
          roles: { 'Common': { readOnly: false } }, // Только Common холст
          members: { [currentUser.uid]: { role: 'Common', displayName: currentUser.displayName || currentUser.email } },
          creator: currentUser.uid // Добавляем создателя
        });

        console.log('Доска успешно создана, ID:', boardRef.id);
        const boardId = boardRef.id;
        const inviteLink = `${window.location.origin}/join/${boardId}`;
        await boardRef.update({ inviteLink });

        currentBoardId = boardId;
        isAdmin = true; // Создатель доски — администратор
        userRole = 'Common';
        boardRoles = { 'Common': { readOnly: false } };

        boardPanel.style.display = 'none';
        sidebar.style.display = 'flex';
        canvasContainer.style.display = 'block'; // Явно включаем canvas
        initBoard();
        console.log('Доска инициализирована:', boardId);
      } catch (error) {
        console.error('Ошибка создания доски:', error, 'Код ошибки:', error.code, 'Сообщение:', error.message);
        alert('Ошибка создания доски: ' + error.message);
      }
    });

    // Присоединение к доске
    document.getElementById('join-board-btn').addEventListener('click', async () => {
      try {
        const link = document.getElementById('join-link').value.trim();
        const boardId = link.split('/join/')[1];
        if (!boardId) {
          alert('Неверная ссылка');
          return;
        }

        const boardDoc = await db.collection('boards').doc(boardId).get();
        if (!boardDoc.exists) {
          alert('Доска не найдена');
          return;
        }

        const boardData = boardDoc.data();
        await db.collection('boards').doc(boardId).update({
          [`members.${currentUser.uid}`]: { role: 'Common', displayName: currentUser.displayName || currentUser.email }
        });

        currentBoardId = boardId;
        isAdmin = boardData.creator === currentUser.uid; // Проверяем, создатель ли пользователь
        userRole = 'Common';
        boardRoles = boardData.roles;

        boardPanel.style.display = 'none';
        sidebar.style.display = 'flex';
        canvasContainer.style.display = 'block';
        initBoard();
        console.log('Присоединились к доске:', boardId, 'Пользователь:', currentUser.displayName || currentUser.email);
      } catch (error) {
        console.error('Ошибка присоединения к доске:', error);
        alert('Ошибка присоединения к доске');
      }
    });

    // Инициализация доски
    function initBoard() {
      try {
        // Проверяем размеры canvas-container
        const containerRect = canvasContainer.getBoundingClientRect();
        console.log('Размеры canvas-container:', containerRect);

        stage = new Konva.Stage({
          container: 'canvas-container',
          width: containerRect.width || window.innerWidth - (window.innerWidth < 768 ? 0 : 256),
          height: containerRect.height || window.innerHeight
        });

        backgroundLayer = new Konva.Layer({ listening: false });
        stage.add(backgroundLayer);
        updateGrid(stage, backgroundLayer);

        transformerLayer = new Konva.Layer();
        transformer = new Konva.Transformer({
          nodes: [],
          keepRatio: false,
          enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
          boundBoxFunc: (oldBox, newBox) => ({
            width: newBox.width >= 50 ? newBox.width : oldBox.width,
            height: newBox.height >= 50 ? newBox.height : oldBox.height
          })
        });
        transformerLayer.add(transformer);
        stage.add(transformerLayer);

        canvases = { 'Common': new Konva.Layer() };
        stage.add(canvases[currentCanvas]);
        stage.batchDraw(); // Явный рендеринг

        console.log('Холст Common добавлен:', canvases[currentCanvas]);

        // Отложенная загрузка элементов
        setTimeout(loadVisibleElements, 500);
        updateRolesList();
        setupEventListeners();
        console.log('Доска инициализирована');
      } catch (err) {
        console.error('Ошибка инициализации доски:', err);
      }
    }

    // Загрузка видимых элементов
    async function loadVisibleElements() {
      try {
        const scale = stage.scaleX();
        const pos = stage.position();
        const width = stage.width() / scale;
        const height = stage.height() / scale;
        const xMin = -pos.x / scale - width / 2;
        const xMax = xMin + width;
        const yMin = -pos.y / scale - height / 2;
        const yMax = yMin + height;

        console.log('Загрузка элементов для области:', { xMin, xMax, yMin, yMax });

        const snapshot = await db.collection(`boards/${currentBoardId}/elements`)
          .where('x', '>=', xMin)
          .where('x', '<=', xMax)
          .get();

        snapshot.forEach(doc => {
          const data = doc.data();
          const elementId = doc.id;
          const role = data.role || 'Common';

          if (data.y < yMin || data.y > yMax) return;
          if (!canvases[role]) return;

          const existing = canvases[role].findOne(`#${elementId}`);
          if (existing) return;

          const group = createElementFromData(data, elementId);
          group.id(elementId);
          canvases[role].add(group);
          console.log('Добавлен элемент:', elementId);
        });

        stage.batchDraw();
      } catch (error) {
        console.error('Ошибка загрузки видимых элементов:', error);
        alert('Ошибка загрузки элементов: ' + error.message);
      }
    }

    // Создание элемента на основе данных
    function createElementFromData(data, elementId) {
      const group = new Konva.Group({
        x: data.x,
        y: data.y,
        width: data.width,
        height: data.height,
        draggable: isEditable(data.role),
        name: data.type
      });

      const bg = new Konva.Rect({
        width: data.width,
        height: data.height,
        fill: data.bgFill || '#ffffff',
        stroke: '#d1d5db',
        strokeWidth: 2,
        cornerRadius: 4,
        shadowColor: 'rgba(0,0,0,0.1)',
        shadowBlur: 5
      });

      group.add(bg);

      if (data.type === 'task') {
        const titleText = new Konva.Text({
          x: 8,
          y: 8,
          text: data.title,
          fontSize: 12,
          fontFamily: 'Arial',
          fontStyle: 'bold',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        const descText = new Konva.Text({
          x: 8,
          y: 32,
          text: data.desc,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        const statusText = new Konva.Text({
          x: 8,
          y: data.height - 24,
          text: `Status: ${data.status}`,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: data.status === 'Завершено' ? '#22c55e' : data.status === 'В процессе' ? '#f59e0b' : '#ef4444',
          width: data.width - 16,
          padding: 4
        });

        group.add(titleText, descText, statusText);
      } else if (data.type === 'pdf') {
        const text = new Konva.Text({
          x: 8,
          y: 8,
          text: data.content,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });
        group.add(text);
      } else if (data.type === 'note') {
        const titleText = new Konva.Text({
          x: 8,
          y: 8,
          text: data.title,
          fontSize: 12,
          fontFamily: 'Arial',
          fontStyle: 'bold',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        const contentText = new Konva.Text({
          x: 8,
          y: 32,
          text: data.content,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        group.add(titleText, contentText);
      } else if (data.type === 'comment') {
        const authorText = new Konva.Text({
          x: 8,
          y: 8,
          text: `From: ${data.author} (${data.date})`,
          fontSize: 10,
          fontFamily: 'Arial',
          fontStyle: 'italic',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        const contentText = new Konva.Text({
          x: 8,
          y: 32,
          text: data.content,
          fontSize: 10,
          fontFamily: 'Arial',
          fill: 'black',
          width: data.width - 16,
          padding: 4
        });

        group.add(authorText, contentText);
      } else if (data.type === 'text') {
        const contentText = new Konva.Text({
          x: 8,
          y: 8,
          text: data.content,
          fontSize: 12,
          fontFamily: 'Arial',
          fill: 'white',
          width: data.width - 16,
          padding: 4
        });
        group.add(contentText);
      }

      if (isEditable(data.role)) {
        group.on('dblclick', () => editElement(group, data.type));
        group.on('dragend', () => updateElementData(group, elementId));
        group.on('transformend', () => updateElementSize(group, elementId));
      }

      return group;
    }

    // Проверка возможности редактирования роли
    function isEditable(role) {
      return role === 'Common';
    }

    // Обновление списка ролей
    function updateRolesList() {
      try {
        rolesList.innerHTML = '';
        const li = document.createElement('li');
        li.className = `p-2 rounded cursor-pointer transition bg-gray-700 hover:bg-gray-600 bg-blue-600 fade-in`;
        li.textContent = 'Common';
        li.addEventListener('click', () => {
          currentCanvas = 'Common';
          stage.getLayers().forEach(layer => {
            if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
          });
          stage.add(canvases['Common']);
          stage.batchDraw();
          console.log('Переключено на холст: Common');
        });
        rolesList.appendChild(li);
        updateTaskRoleSelect();
        updateAdminPanel();
      } catch (error) {
        console.error('Ошибка обновления списка ролей:', error);
      }
    }

    // Обновление селекта ролей для задачи
    function updateTaskRoleSelect() {
      try {
        const taskRoleSelect = document.getElementById('task-role');
        taskRoleSelect.innerHTML = '<option value="Common">Common</option>';
      } catch (error) {
        console.error('Ошибка обновления селекта ролей:', error);
      }
    }

    // Обновление админ-панели
    async function updateAdminPanel() {
      try {
        // Показываем кнопку админ-панели только для администратора
        toggleAdminBtn.style.display = isAdmin ? 'block' : 'none';
        document.getElementById('invite-link').value = `${window.location.origin}/join/${currentBoardId}`;
        console.log('Админ-панель обновлена, isAdmin:', isAdmin);
      } catch (error) {
        console.error('Ошибка обновления админ-панели:', error);
      }
    }

    // Настройка обработчиков событий
    function setupEventListeners() {
      try {
        // Переключение админ-панели
        toggleAdminBtn.addEventListener('click', () => {
          adminPanel.style.display = adminPanel.style.display === 'none' ? 'block' : 'none';
          adminPanel.classList.toggle('slide-in', adminPanel.style.display === 'block');
          console.log('Админ-панель переключена:', adminPanel.style.display);
        });

        // Генерация ссылки-приглашения
        document.getElementById('generate-link').addEventListener('click', async () => {
          document.getElementById('invite-link').value = `${window.location.origin}/join/${currentBoardId}`;
          console.log('Ссылка-приглашение обновлена');
        });

        // Добавление роли
        document.getElementById('add-role').addEventListener('click', async () => {
          try {
            const roleInput = document.getElementById('role-input');
            const role = roleInput.value.trim();
            if (role && !boardRoles[role]) {
              boardRoles[role] = { readOnly: false };
              await db.collection('boards').doc(currentBoardId).update({
                roles: boardRoles
              });
              updateRolesList();
              roleInput.value = '';
              console.log('Роль добавлена:', role);
            }
          } catch (error) {
            console.error('Ошибка добавления роли:', error);
          }
        });

        // Назначение роли
        document.getElementById('assign-role').addEventListener('click', async () => {
          try {
            const uid = document.getElementById('member-select').value;
            const role = document.getElementById('role-select').value;
            await db.collection('boards').doc(currentBoardId).update({
              [`members.${uid}.role`]: role
            });
            console.log(`Назначена роль ${role} пользователю ${uid}`);
          } catch (error) {
            console.error('Ошибка назначения роли:', error);
          }
        });

        // Контекстное меню
        let contextTarget = null;
        let contextPos = { x: 0, y: 0 };
        let longPressTimer = null;
        const showContextMenu = (x, y, intersection) => {
          contextPos.x = x;
          contextPos.y = y;
          contextTarget = intersection ? getGroupAncestor(intersection) : null;

          const menuItems = ['create-task', 'create-pdf', 'create-note', 'create-comment', 'create-text', 'delete-element', 'export-pdf'];
          menuItems.forEach(item => document.getElementById(item).style.display = 'none');

          if (contextTarget && isEditable(contextTarget.attrs.role)) {
            document.getElementById('delete-element').style.display = 'block';
            if (contextTarget.hasName('pdf')) {
              document.getElementById('export-pdf').style.display = 'block';
            }
          } else if (isEditable(currentCanvas)) {
            ['create-task', 'create-pdf', 'create-note', 'create-comment', 'create-text'].forEach(id => {
              document.getElementById(id).style.display = 'block';
            });
          }

          contextMenu.style.left = `${x}px`;
          contextMenu.style.top = `${y}px`;
          contextMenu.style.display = 'block';
        };

        stage.on('contextmenu', (e) => {
          e.evt.preventDefault();
          const pos = stage.getPointerPosition();
          const intersection = stage.getIntersection(pos);
          showContextMenu(e.evt.clientX, e.evt.clientY, intersection);
        });

        // Долгое нажатие на мобильных устройствах
        stage.on('touchstart', (e) => {
          const pos = stage.getPointerPosition();
          const intersection = stage.getIntersection(pos);
          longPressTimer = setTimeout(() => {
            showContextMenu(pos.x, pos.y, intersection);
          }, 500);
        });

        stage.on('touchend touchmove', () => {
          if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
          }
        });

        document.addEventListener('click', (e) => {
          if (!contextMenu.contains(e.target)) {
            contextMenu.style.display = 'none';
            contextTarget = null;
          }
        });

        // Выбор трансформера
        stage.on('mousedown touchstart', (e) => {
          const pos = stage.getPointerPosition();
          const intersection = stage.getIntersection(pos);
          if (!intersection || intersection.getLayer() === backgroundLayer) {
            transformer.nodes([]);
          } else {
            const group = getGroupAncestor(intersection);
            if (group && isEditable(group.attrs.role)) {
              transformer.nodes([group]);
            } else {
              transformer.nodes([]);
            }
          }
          stage.batchDraw();
        });

        // Создание задачи
        document.getElementById('create-task').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('task-modal').style.display = 'flex';
          document.getElementById('task-title').value = '';
          document.getElementById('task-desc').value = '';
        });

        // Отмена задачи
        document.getElementById('cancel-task').addEventListener('click', () => {
          document.getElementById('task-modal').style.display = 'none';
          document.getElementById('task-title').value = '';
          document.getElementById('task-desc').value = '';
        });

        // Сохранение задачи
        let editingTask = null;
        document.getElementById('save-task').addEventListener('click', async () => {
          try {
            const title = document.getElementById('task-title').value.trim();
            const desc = document.getElementById('task-desc').value.trim();
            const status = document.getElementById('task-status').value;
            const role = document.getElementById('task-role').value || currentCanvas;

            if (!title || !desc) {
              alert('Заполните заголовок и описание');
              return;
            }

            if (!isEditable(role)) {
              alert('Нет прав на редактирование');
              return;
            }

            const taskData = {
              type: 'task',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              title,
              desc,
              status,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(taskData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(taskData);
            }

            document.getElementById('task-modal').style.display = 'none';
            document.getElementById('task-title').value = '';
            document.getElementById('task-desc').value = '';
          } catch (error) {
            console.error('Ошибка сохранения задачи:', error);
          }
        });

        // Создание PDF
        document.getElementById('create-pdf').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('pdf-modal').style.display = 'flex';
          document.getElementById('pdf-content').value = '';
        });

        // Отмена PDF
        document.getElementById('cancel-pdf').addEventListener('click', () => {
          document.getElementById('pdf-modal').style.display = 'none';
          document.getElementById('pdf-content').value = '';
        });

        // Сохранение PDF
        document.getElementById('save-pdf').addEventListener('click', async () => {
          try {
            const content = document.getElementById('pdf-content').value.trim();
            const role = currentCanvas;

            if (!content) {
              alert('Заполните содержимое');
              return;
            }

            if (!isEditable(role)) {
              alert('Нет прав на редактирование');
              return;
            }

            const pdfData = {
              type: 'pdf',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              content,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(pdfData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(pdfData);
            }

            document.getElementById('pdf-modal').style.display = 'none';
            document.getElementById('pdf-content').value = '';
          } catch (error) {
            console.error('Ошибка сохранения PDF:', error);
          }
        });

        // Создание заметки
        document.getElementById('create-note').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('note-modal').style.display = 'flex';
          document.getElementById('note-title').value = '';
          document.getElementById('note-content').value = '';
        });

        // Отмена заметки
        document.getElementById('cancel-note').addEventListener('click', () => {
          document.getElementById('note-modal').style.display = 'none';
          document.getElementById('note-title').value = '';
          document.getElementById('note-content').value = '';
        });

        // Сохранение заметки
        document.getElementById('save-note').addEventListener('click', async () => {
          try {
            const title = document.getElementById('note-title').value.trim();
            const content = document.getElementById('note-content').value.trim();
            const role = currentCanvas;

            if (!title || !content) {
              alert('Заполните заголовок и содержимое');
              return;
            }

            if (!isEditable(role)) {
              alert('Нет прав на редактирование');
              return;
            }

            const noteData = {
              type: 'note',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              title,
              content,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(noteData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(noteData);
            }

            document.getElementById('note-modal').style.display = 'none';
            document.getElementById('note-title').value = '';
            document.getElementById('note-content').value = '';
          } catch (error) {
            console.error('Ошибка сохранения заметки:', error);
          }
        });

        // Создание комментария
        document.getElementById('create-comment').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('comment-modal').style.display = 'flex';
          document.getElementById('comment-author').value = currentUser.displayName || currentUser.email;
          document.getElementById('comment-content').value = '';
        });

        // Отмена комментария
        document.getElementById('cancel-comment').addEventListener('click', () => {
          document.getElementById('comment-modal').style.display = 'none';
          document.getElementById('comment-content').value = '';
        });

        // Сохранение комментария
        document.getElementById('save-comment').addEventListener('click', async () => {
          try {
            const author = document.getElementById('comment-author').value.trim();
            const content = document.getElementById('comment-content').value.trim();
            const role = currentCanvas;
            const date = new Date().toLocaleDateString();

            if (!author || !content) {
              alert('Заполните автора и содержимое');
              return;
            }

            if (!isEditable(role)) {
              alert('Нет прав на редактирование');
              return;
            }

            const commentData = {
              type: 'comment',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              author,
              content,
              date,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(commentData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(commentData);
            }

            document.getElementById('comment-modal').style.display = 'none';
            document.getElementById('comment-content').value = '';
          } catch (error) {
            console.error('Ошибка сохранения комментария:', error);
          }
        });

        // Создание текста
        document.getElementById('create-text').addEventListener('click', () => {
          contextMenu.style.display = 'none';
          document.getElementById('text-modal').style.display = 'flex';
          document.getElementById('text-content').value = '';
        });

        // Отмена текста
        document.getElementById('cancel-text').addEventListener('click', () => {
          document.getElementById('text-modal').style.display = 'none';
          document.getElementById('text-content').value = '';
        });

        // Сохранение текста
        document.getElementById('save-text').addEventListener('click', async () => {
          try {
            const content = document.getElementById('text-content').value.trim();
            const role = currentCanvas;

            if (!content) {
              alert('Заполните содержимое');
              return;
            }

            if (!isEditable(role)) {
              alert('Нет прав на редактирование');
              return;
            }

            const textData = {
              type: 'text',
              role,
              x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
              y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
              width: 150,
              height: 120,
              bgFill: '#ffffff',
              content,
              createdBy: currentUser.uid
            };

            if (editingTask) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(editingTask.id()).update(textData);
              editingTask = null;
            } else {
              await db.collection(`boards/${currentBoardId}/elements`).add(textData);
            }

            document.getElementById('text-modal').style.display = 'none';
            document.getElementById('text-content').value = '';
          } catch (error) {
            console.error('Ошибка сохранения текста:', error);
          }
        });

        // Удаление элемента
        document.getElementById('delete-element').addEventListener('click', async () => {
          try {
            if (contextTarget && isEditable(contextTarget.attrs.role)) {
              await db.collection(`boards/${currentBoardId}/elements`).doc(contextTarget.id()).delete();
              contextMenu.style.display = 'none';
              contextTarget = null;
            }
          } catch (error) {
            console.error('Ошибка удаления элемента:', error);
          }
        });

        // Экспорт PDF
        document.getElementById('export-pdf').addEventListener('click', () => {
          try {
            if (contextTarget && contextTarget.hasName('pdf')) {
              const { jsPDF } = window.jspdf;
              const doc = new jsPDF();
              const content = contextTarget.find('Text')[0].text();
              doc.text(content, 10, 10);
              doc.save('exported.pdf');
              contextMenu.style.display = 'none';
              console.log('PDF экспортирован');
            }
          } catch (error) {
            console.error('Ошибка экспорта PDF:', error);
          }
        });

        // Масштабирование и панорамирование
        let scale = 1;
        const zoomHandler = debounce((e) => {
          e.evt.preventDefault();
          const oldScale = scale;
          const pointer = stage.getPointerPosition();
          const mousePointTo = {
            x: pointer.x / oldScale - stage.x() / oldScale,
            y: pointer.y / oldScale - stage.y() / oldScale
          };

          const deltaY = e.evt.deltaY;
          scale *= (deltaY > 0 ? 0.9 : 1.1);
          scale = Math.max(0.3, Math.min(scale, 4));

          stage.scale({ x: scale, y: scale });
          const newPos = {
            x: -(mousePointTo.x - pointer.x / scale) * scale,
            y: -(mousePointTo.y - pointer.y / scale) * scale
          };
          stage.position(newPos);
          updateGrid(stage, backgroundLayer);
          loadVisibleElements();
          stage.batchDraw();
        }, 100);

        stage.on('wheel', zoomHandler);

        // Масштабирование и панорамирование на сенсорных устройствах
        let lastDist = 0;
        let startPos = null;
        stage.on('touchstart', (e) => {
          if (e.evt.touches.length === 2) {
            const touch1 = e.evt.touches[0];
            const touch2 = e.evt.touches[1];
            lastDist = Math.sqrt((touch1.clientX - touch2.clientX) ** 2 + (touch1.clientY - touch2.clientY) ** 2);
            startPos = stage.position();
          }
        });

        stage.on('touchmove', (e) => {
          if (e.evt.touches.length === 2) {
            e.evt.preventDefault();
            const touch1 = e.evt.touches[0];
            const touch2 = e.evt.touches[1];
            const dist = Math.sqrt((touch1.clientX - touch2.clientX) ** 2 + (touch1.clientY - touch2.clientY) ** 2);
            if (dist > 0) {
              const oldScale = scale;
              scale *= (dist / lastDist);
              scale = Math.max(0.3, Math.min(scale, 4));
              stage.scale({ x: scale, y: scale });
              updateGrid(stage, backgroundLayer);
              loadVisibleElements();
              stage.batchDraw();
              lastDist = dist;
            }
          } else if (e.evt.touches.length === 1 && startPos) {
            const touch = e.evt.touches[0];
            stage.position({
              x: startPos.x + (touch.clientX - startPos.x),
              y: startPos.y + (touch.clientY - startPos.y)
            });
            updateGrid(stage, backgroundLayer);
            loadVisibleElements();
            stage.batchDraw();
          }
        });

        stage.on('touchend', () => {
          lastDist = 0;
          startPos = null;
        });

        // Панорамирование при перетаскивании
        let isDragging = false;
        let dragStartPos = { x: 0, y: 0 };
        stage.on('mousedown touchstart', (e) => {
          if (e.evt.ctrlKey && e.evt.button === 0 || e.evt.type === 'touchstart') {
            isDragging = true;
            dragStartPos = stage.getPointerPosition();
          }
        });

        stage.on('mousemove touchmove', (e) => {
          if (isDragging) {
            const pos = stage.getPointerPosition();
            const dx = pos.x - dragStartPos.x;
            const dy = pos.y - dragStartPos.y;
            stage.position({
              x: stage.x() + dx,
              y: stage.y() + dy
            });
            updateGrid(stage, backgroundLayer);
            loadVisibleElements();
            stage.batchDraw();
            dragStartPos = pos;
          }
        });

        stage.on('mouseup touchend', () => {
          isDragging = false;
        });

        // Изменение размера окна
        window.addEventListener('resize', () => {
          const containerRect = canvasContainer.getBoundingClientRect();
          stage.width(containerRect.width || window.innerWidth - (window.innerWidth < 768 ? 0 : 256));
          stage.height(containerRect.height || window.innerHeight);
          updateGrid(stage, backgroundLayer);
          stage.batchDraw();
          console.log('Окно изменено, новые размеры:', stage.width(), stage.height());
        });
      } catch (error) {
        console.error('Ошибка настройки обработчиков событий:', error);
      }
    }

    // Получение предка-группы
    function getGroupAncestor(node) {
      let currentNode = node;
      while (currentNode && currentNode.getType() !== 'Stage') {
        if (currentNode.hasName('task') || currentNode.hasName('pdf') || currentNode.hasName('note') || currentNode.hasName('comment') || currentNode.hasName('text')) {
          return currentNode;
        }
        currentNode = currentNode.getParent();
      }
      return null;
    }

    // Редактирование элемента
    function editElement(group, type) {
      if (!isEditable(group.attrs.role)) return;

      if (type === 'task') {
        editingTask = group;
        document.getElementById('task-modal').style.display = 'flex';
        document.getElementById('task-title').value = group.find('Text')[0].text();
        document.getElementById('task-desc').value = group.find('Text')[1].text();
        document.getElementById('task-status').value = group.find('Text')[2].text().replace('Status: ', '');
      } else if (type === 'pdf') {
        editingTask = group;
        document.getElementById('pdf-modal').style.display = 'flex';
        document.getElementById('pdf-content').value = group.find('Text')[0].text();
      } else if (type === 'note') {
        editingTask = group;
        document.getElementById('note-modal').style.display = 'flex';
        document.getElementById('note-title').value = group.find('Text')[0].text();
        document.getElementById('note-content').value = group.find('Text')[1].text();
      } else if (type === 'comment') {
        editingTask = group;
        document.getElementById('note-modal').style.display = 'flex';
        document.getElementById('comment-author').value = group.find('Text')[0].text().split(' ')[1];
        document.getElementById('comment-content').value = group.find('Text')[1].text();
      } else if (type === 'text') {
        editingTask = group;
        document.getElementById('text-modal').style.display = 'flex';
        document.getElementById('text-content').value = group.find('Text')[0].text();
      }
    }

    // Обновление размера элемента
    async function updateElementSize(group, elementId) {
      try {
        const newWidth = group.width() * group.scaleX();
        const newHeight = group.height() * group.scaleY();
        group.setAttrs({
          width: newWidth,
          height: newHeight,
          scaleX: 1,
          scaleY: 1
        });

        const bg = group.find('Rect')[0];
        bg.setAttrs({ width: newWidth, height: newHeight });

        const texts = group.find('Text');
        texts.forEach((text, i) => {
          text.width(newWidth - 16);
          if (group.hasName('task') && i === 2) {
            text.y(newHeight - 24);
          }
        });

        await db.collection(`boards/${currentBoardId}/elements`).doc(elementId).update({
          width: newWidth,
          height: newHeight
        });

        stage.batchDraw();
        console.log(`${group.name()} изменен размер: ширина=${newWidth}, высота=${newHeight}`);
      } catch (error) {
        console.error('Ошибка обновления размера:', error);
      }
    }

    // Обновление данных элемента
    async function updateElementData(group, elementId) {
      try {
        await db.collection(`boards/${currentBoardId}/elements`).doc(elementId).update({
          x: group.x(),
          y: group.y()
        });
        stage.batchDraw();
        console.log(`Элемент ${elementId} перемещен`);
      } catch (error) {
        console.error('Ошибка обновления позиции:', error);
      }
    }
  </script>
</body>
</html>