<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Task Management Board</title>
  <link rel="icon" href="data:,">
  <script src="https://unpkg.com/konva@8.3.5/konva.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    @keyframes slide-in {
      from { transform: translateX(-100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slide-out {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(-100%); opacity: 0; }
    }
    @keyframes fade-in {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .slide-in { animation: slide-in 0.3s ease-out forwards; }
    .slide-out { animation: slide-out 0.3s ease-out forwards; }
    .fade-in { animation: fade-in 0.3s ease-out; }
    .card-hover:hover { transform: scale(1.02); transition: transform 0.2s ease; }
    body { background-color: #1f2937; color: #ffffff; }
    #admin-panel, #auth-modal { z-index: 30; }
    #canvas-container { position: relative; overflow: hidden; }
    #sidebar-toggle { position: absolute; top: 10px; left: 10px; z-index: 40; }
    @media (max-width: 768px) {
      #sidebar { width: 256px; height: 100%; position: fixed; top: 0; left: -256px; transition: left 0.3s ease; z-index: 40; }
      #sidebar.open { left: 0; }
      #admin-panel { width: 80%; transform: translateX(100%); transition: transform 0.3s ease; }
      #admin-panel.open { transform: translateX(0); }
      #canvas-container { width: 100%; }
      .modal-content { width: 90%; max-width: 400px; }
      #context-menu { width: 150px; font-size: 14px; }
      input, textarea, select { font-size: 14px; }
    }
    @media (min-width: 769px) {
      #sidebar { width: 256px; position: fixed; left: -256px; transition: left 0.3s ease; }
      #sidebar.open { left: 0; }
      #admin-panel { width: 320px; transform: none; }
      #sidebar-toggle { display: block; }
    }
  </style>
</head>
<body class="flex h-screen overflow-hidden">
  <!-- Кнопка переключения боковой панели -->
  <button id="sidebar-toggle" class="bg-blue-600 text-white p-2 rounded hover:bg-blue-700">
    ☰
  </button>

  <!-- Боковая панель -->
  <div id="sidebar" class="bg-gray-800 p-4 flex flex-col">
    <h2 class="text-xl font-bold mb-4">Роли</h2>
    <ul id="roles-list" class="space-y-2 flex-1"></ul>
    <button id="toggle-admin" class="mt-auto bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition hidden">Админ-панель</button>
    <button id="logout" class="mt-2 bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition">Выйти</button>
  </div>

  <!-- Админ-панель -->
  <div id="admin-panel" class="hidden w-80 bg-gray-800 p-4 absolute right-0 top-0 h-full">
    <h2 class="text-xl font-bold mb-4">Админ-панель</h2>
    <div class="space-y-4">
      <div>
        <label class="block text-sm font-medium">Приглашение по ссылке</label>
        <input id="invite-link" type="text" readonly class="w-full bg-gray-700 p-2 rounded">
        <button id="generate-link" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 mt-2">Сгенерировать ссылку</button>
      </div>
      <div>
        <label class="block text-sm font-medium">Добавить роль</label>
        <input id="role-input" type="text" placeholder="Введите роль" class="w-full bg-gray-700 p-2 rounded">
        <select id="user-select" class="w-full bg-gray-700 p-2 rounded mt-2">
          <option value="">Выберите пользователя</option>
        </select>
        <button id="add-role" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 mt-2">Добавить</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно аутентификации -->
  <div id="auth-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-30">
    <div class="bg-gray-800 p-6 rounded-lg w-96 modal-content fade-in">
      <h3 id="auth-title" class="text-lg font-bold mb-4">Вход в приложение</h3>
      <div id="auth-form" class="space-y-4">
        <div>
          <label class="block text-sm font-medium">Email</label>
          <input id="email-input" type="email" placeholder="Введите email" class="w-full bg-gray-700 p-2 rounded">
        </div>
        <div>
          <label class="block text-sm font-medium">Пароль</label>
          <input id="password-input" type="password" placeholder="Введите пароль" class="w-full bg-gray-700 p-2 rounded">
        </div>
        <div class="flex justify-between">
          <button id="auth-submit" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 w-full">Войти</button>
        </div>
        <div class="flex justify-between">
          <button id="toggle-auth-mode" class="text-blue-400 hover:underline">Нет аккаунта? Зарегистрируйтесь</button>
          <button id="google-signin" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex items-center">
            <img src="https://www.google.com/favicon.ico" class="w-5 h-5 mr-2" alt="Google"> Google
          </button>
        </div>
        <div id="auth-error" class="text-red-500 text-sm hidden"></div>
      </div>
    </div>
  </div>

  <!-- Холст -->
  <div id="canvas-container" class="flex-1 bg-gray-700 relative hidden"></div>

  <!-- Контекстное меню -->
  <div id="context-menu" class="hidden absolute bg-gray-800 text-white rounded shadow-lg p-2 z-20">
    <button id="create-task" class="block px-4 py-2 hover:bg-gray-600 w-full text-left">Создать задачу</button>
    <button id="create-pdf" class="block px-4 py-2 hover:bg-gray-600 w-full text-left">Создать PDF</button>
    <button id="create-note" class="block px-4 py-2 hover:bg-gray-600 w-full text-left">Создать заметку</button>
    <button id="create-comment" class="block px-4 py-2 hover:bg-gray-600 w-full text-left">Создать комментарий</button>
    <button id="create-text" class="block px-4 py-2 hover:bg-gray-600 w-full text-left">Создать текст</button>
    <button id="delete-element" class="block px-4 py-2 hover:bg-gray-600 w-full text-left hidden">Удалить</button>
  </div>

  <!-- Модальное окно для задачи -->
  <div id="task-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-96 modal-content fade-in">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать задачу</h3>
      <input id="task-title" type="text" placeholder="Заголовок задачи" class="w-full bg-gray-700 p-2 rounded mb-2">
      <textarea id="task-desc" placeholder="Описание задачи" class="w-full bg-gray-700 p-2 rounded mb-2"></textarea>
      <select id="task-status" class="w-full bg-gray-700 p-2 rounded mb-2">
        <option value="К выполнению">К выполнению</option>
        <option value="В процессе">В процессе</option>
        <option value="Завершено">Завершено</option>
      </select>
      <select id="task-role" class="w-full bg-gray-700 p-2 rounded mb-2">
        <option value="">Выберите роль</option>
      </select>
      <div class="flex justify-end space-x-2">
        <button id="cancel-task" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700">Отмена</button>
        <button id="save-task" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Сохранить</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно для PDF -->
  <div id="pdf-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-96 modal-content fade-in">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать PDF</h3>
      <textarea id="pdf-content" placeholder="Содержимое PDF" class="w-full bg-gray-700 p-2 rounded mb-2"></textarea>
      <select id="task-role" class="w-full bg-gray-700 p-2 rounded mb-2">
        <option value="">Выберите роль</option>
      </select>
      <div class="flex justify-end space-x-2">
        <button id="cancel-pdf" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700">Отмена</button>
        <button id="save-pdf" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Сохранить</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно для заметки -->
  <div id="note-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-96 modal-content fade-in">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать заметку</h3>
      <input id="note-title" type="text" placeholder="Заголовок заметки" class="w-full bg-gray-700 p-2 rounded mb-2">
      <textarea id="note-content" placeholder="Содержимое заметки" class="w-full bg-gray-700 p-2 rounded mb-2"></textarea>
      <select id="task-role" class="w-full bg-gray-700 p-2 rounded mb-2">
        <option value="">Выберите роль</option>
      </select>
      <div class="flex justify-end space-x-2">
        <button id="cancel-note" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700">Отмена</button>
        <button id="save-note" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Сохранить</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно для комментария -->
  <div id="comment-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-96 modal-content fade-in">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать комментарий</h3>
      <input id="comment-author" type="text" placeholder="Автор" class="w-full bg-gray-700 p-2 rounded mb-2">
      <textarea id="comment-content" placeholder="Текст комментария" class="w-full bg-gray-700 p-2 rounded mb-2"></textarea>
      <select id="task-role" class="w-full bg-gray-700 p-2 rounded mb-2">
        <option value="">Выберите роль</option>
      </select>
      <div class="flex justify-end space-x-2">
        <button id="cancel-comment" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700">Отмена</button>
        <button id="save-comment" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Сохранить</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно для текста -->
  <div id="text-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-20">
    <div class="bg-gray-800 p-6 rounded-lg w-96 modal-content fade-in">
      <h3 class="text-lg font-bold mb-4">Создать/Редактировать текст</h3>
      <textarea id="text-content" placeholder="Введите текст" class="w-full bg-gray-700 p-2 rounded mb-2"></textarea>
      <select id="task-role" class="w-full bg-gray-700 p-2 rounded mb-2">
        <option value="">Выберите роль</option>
      </select>
      <div class="flex justify-end space-x-2">
        <button id="cancel-text" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700">Отмена</button>
        <button id="save-text" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Сохранить</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';
    import { getFirestore, collection, doc, addDoc, getDoc, updateDoc, setDoc, arrayUnion, onSnapshot } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyAdPjUWf2gkcZxOAkQb-3hkjKtuETOVRhc",
      authDomain: "tawn-71d42.firebaseapp.com",
      projectId: "tawn-71d42",
      storageBucket: "tawn-71d42.firebasestorage.app",
      messagingSenderId: "1098831654973",
      appId: "1:1098831654973:web:4bdc2fb530d7acb17afa54",
      measurementId: "G-55XQ2KBXW9"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    let currentUser = null;
    let currentBoardId = null;
    let isSignInMode = true;
    let unsubscribeBoardSnapshot = null;

    window.onload = async function() {
      try {
        if (!window.Konva) throw new Error('Konva.js not loaded');
        if (!window.jspdf) throw new Error('jsPDF not loaded');

        const authModal = document.getElementById('auth-modal');
        const authTitle = document.getElementById('auth-title');
        const authSubmit = document.getElementById('auth-submit');
        const toggleAuthMode = document.getElementById('toggle-auth-mode');
        const authError = document.getElementById('auth-error');
        const emailInput = document.getElementById('email-input');
        const passwordInput = document.getElementById('password-input');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggle = document.getElementById('sidebar-toggle');

        function toggleAuthModeUI() {
          isSignInMode = !isSignInMode;
          authTitle.textContent = isSignInMode ? 'Вход в приложение' : 'Регистрация';
          authSubmit.textContent = isSignInMode ? 'Войти' : 'Зарегистрироваться';
          toggleAuthMode.textContent = isSignInMode ? 'Нет аккаунта? Зарегистрируйтесь' : 'Уже есть аккаунт? Войдите';
          authError.classList.add('hidden');
          emailInput.value = '';
          passwordInput.value = '';
        }

        toggleAuthMode.addEventListener('click', toggleAuthModeUI);

        authSubmit.addEventListener('click', async function() {
          const email = emailInput.value.trim();
          const password = passwordInput.value.trim();
          authError.classList.add('hidden');

          if (!email || !password) {
            authError.textContent = 'Введите email и пароль';
            authError.classList.remove('hidden');
            return;
          }

          try {
            if (isSignInMode) {
              await signInWithEmailAndPassword(auth, email, password);
            } else {
              const userCredential = await createUserWithEmailAndPassword(auth, email, password);
              await setDoc(doc(db, 'users', userCredential.user.uid), {
                email: email,
                displayName: email.split('@')[0]
              });
            }
          } catch (error) {
            let errorMessage = 'Произошла ошибка';
            switch (error.code) {
              case 'auth/invalid-email': errorMessage = 'Неверный формат email'; break;
              case 'auth/user-not-found': errorMessage = 'Пользователь не найден'; break;
              case 'auth/wrong-password': errorMessage = 'Неверный пароль'; break;
              case 'auth/email-already-in-use': errorMessage = 'Email уже используется'; break;
              case 'auth/weak-password': errorMessage = 'Пароль должен содержать не менее 6 символов'; break;
              default: errorMessage = error.message;
            }
            authError.textContent = errorMessage;
            authError.classList.remove('hidden');
            console.error('Auth error:', error);
          }
        });

        onAuthStateChanged(auth, async function(user) {
          if (user) {
            currentUser = user;
            authModal.classList.add('hidden');
            document.getElementById('canvas-container').classList.remove('hidden');
            sidebar.classList.add('open');
            document.getElementById('comment-author').value = user.displayName || user.email || 'Пользователь';
            await loadUserBoard();
          } else {
            authModal.classList.remove('hidden');
            document.getElementById('canvas-container').classList.add('hidden');
            sidebar.classList.remove('open');
            if (unsubscribeBoardSnapshot) unsubscribeBoardSnapshot();
          }
        });

        document.getElementById('google-signin').addEventListener('click', async function() {
          try {
            const provider = new GoogleAuthProvider();
            const result = await signInWithPopup(auth, provider);
            await setDoc(doc(db, 'users', result.user.uid), {
              email: result.user.email,
              displayName: result.user.displayName || result.user.email.split('@')[0]
            }, { merge: true });
          } catch (error) {
            authError.textContent = error.message;
            authError.classList.remove('hidden');
            console.error('Error signing in with Google:', error);
          }
        });

        document.getElementById('logout').addEventListener('click', async function() {
          try {
            await signOut(auth);
            currentBoardId = null;
            sidebar.classList.remove('open');
            if (unsubscribeBoardSnapshot) unsubscribeBoardSnapshot();
          } catch (error) {
            console.error('Error signing out:', error);
          }
        });

        sidebarToggle.addEventListener('click', function() {
          if (sidebar.classList.contains('open')) {
            sidebar.classList.remove('open');
            sidebar.style.left = '-256px';
          } else {
            sidebar.classList.add('open');
            sidebar.style.left = '0';
            document.getElementById('admin-panel').classList.remove('open', 'slide-in');
          }
        });

        async function loadUserBoard() {
          try {
            const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
            let boardId = userDoc.exists() && userDoc.data().boardId;
            if (!boardId) {
              const boardRef = await addDoc(collection(db, 'boards'), {
                name: `Доска ${currentUser.email}`,
                owner: currentUser.uid,
                users: [currentUser.uid],
                roleAssignments: {},
                canvases: { 'Общий': [] }
              });
              boardId = boardRef.id;
              await updateDoc(doc(db, 'users', currentUser.uid), { boardId });
            }
            currentBoardId = boardId;
            await initBoard();
          } catch (error) {
            console.error('Error loading board:', error);
            alert('Ошибка загрузки доски: ' + error.message);
          }
        }

        async function loadBoardUsers() {
          const userSelect = document.getElementById('user-select');
          userSelect.innerHTML = '<option value="">Выберите пользователя</option>';
          const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
          if (boardDoc.exists()) {
            const users = boardDoc.data().users || [];
            for (const uid of users) {
              const userDoc = await getDoc(doc(db, 'users', uid)).catch(() => null);
              const userData = userDoc?.exists() ? userDoc.data() : null;
              const displayName = userData?.displayName || userData?.email || uid;
              const option = document.createElement('option');
              option.value = uid;
              option.textContent = displayName;
              userSelect.appendChild(option);
            }
          }
        }

        async function initBoard() {
          if (unsubscribeBoardSnapshot) unsubscribeBoardSnapshot();
          const stage = new Konva.Stage({
            container: 'canvas-container',
            width: window.innerWidth,
            height: window.innerHeight,
          });

          const backgroundLayer = new Konva.Layer({ listening: false });
          const gridSpacing = 50;
          function updateGrid() {
            backgroundLayer.destroyChildren();
            const scale = stage.scaleX();
            const stagePos = stage.position();
            const visibleWidth = stage.width() / scale;
            const visibleHeight = stage.height() / scale;
            const startX = Math.floor((-stagePos.x / scale - visibleWidth) / gridSpacing) * gridSpacing;
            const startY = Math.floor((-stagePos.y / scale - visibleHeight) / gridSpacing) * gridSpacing;
            const endX = startX + visibleWidth * 2;
            const endY = startY + visibleHeight * 2;

            for (let y = startY; y < endY; y += gridSpacing) {
              backgroundLayer.add(new Konva.Line({
                points: [startX, y, endX, y],
                stroke: 'rgba(255, 255, 255, 0.2)',
                strokeWidth: 1 / scale,
              }));
            }
            for (let x = startX; x < endX; x += gridSpacing) {
              backgroundLayer.add(new Konva.Line({
                points: [x, startY, x, endY],
                stroke: 'rgba(255, 255, 255, 0.2)',
                strokeWidth: 1 / scale,
              }));
            }
            backgroundLayer.batchDraw();
          }
          stage.add(backgroundLayer);
          updateGrid();

          const transformerLayer = new Konva.Layer();
          const transformer = new Konva.Transformer({
            nodes: [],
            keepRatio: false,
            enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
            boundBoxFunc: function(oldBox, newBox) {
              if (newBox.width < 50 || newBox.height < 50) return oldBox;
              return newBox;
            },
          });
          transformerLayer.add(transformer);
          stage.add(transformerLayer);

          let canvases = { 'Общий': new Konva.Layer() };
          let currentCanvas = 'Общий';
          let roleAssignments = {};
          const rolesList = document.getElementById('roles-list');

          const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
          const boardData = boardDoc.data();
          roleAssignments = boardData.roleAssignments || {};
          Object.keys(boardData.canvases || {}).forEach(function(role) {
            canvases[role] = new Konva.Layer();
            boardData.canvases[role].forEach(function(item) {
              const group = createGroupFromData(item);
              canvases[role].add(group);
            });
          });
          stage.add(canvases[currentCanvas]);

          const isOwner = boardData.owner === currentUser.uid;
          document.getElementById('toggle-admin').classList.toggle('hidden', !isOwner);
          if (isOwner) await loadBoardUsers();
          updateRolesList();

          unsubscribeBoardSnapshot = onSnapshot(doc(db, 'boards', currentBoardId), function(doc) {
            if (!doc.exists()) return;
            const data = doc.data();
            roleAssignments = data.roleAssignments || {};
            Object.keys(canvases).forEach(function(role) {
              if (!data.canvases[role]) {
                canvases[role].destroy();
                delete canvases[role];
              }
            });
            Object.keys(data.canvases || {}).forEach(function(role) {
              if (!canvases[role]) canvases[role] = new Konva.Layer();
              canvases[role].destroyChildren();
              data.canvases[role].forEach(function(item) {
                const group = createGroupFromData(item);
                canvases[role].add(group);
              });
              if (role === currentCanvas) {
                stage.getLayers().forEach(function(layer) {
                  if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
                });
                stage.add(canvases[role]);
                stage.batchDraw();
              }
            });
            updateRolesList();
          });

          function createGroupFromData(data) {
            const group = new Konva.Group({
              x: data.x || 0,
              y: data.y || 0,
              draggable: true,
              name: data.type,
              id: data.id,
              scaleX: data.scaleX || 1,
              scaleY: data.scaleY || 1,
            });

            const bgAttrs = {
              width: data.bg?.width || 200,
              height: data.bg?.height || (data.type === 'pdf' ? 400 : 150),
              fill: data.bg?.fill || (data.type === 'pdf' ? '#f8f8f8' : data.type === 'note' ? '#fefcbf' : data.type === 'comment' ? '#e5e7eb' : data.type === 'text' ? 'transparent' : '#ffffff'),
              stroke: data.bg?.stroke || '#d1d5db',
              strokeWidth: data.bg?.strokeWidth || (data.type === 'text' ? 1 : 2),
              cornerRadius: data.bg?.cornerRadius || 8,
              shadowColor: data.bg?.shadowColor || 'rgba(0,0,0,0.2)',
              shadowBlur: data.bg?.shadowBlur || 10,
              shadowOffset: data.bg?.shadowOffset || (data.type === 'comment' ? { x: 0, y: 2 } : { x: 2, y: 2 }),
            };

            const bg = new Konva.Rect(bgAttrs);
            let textNodes = [];

            if (data.type === 'task') {
              const titleText = new Konva.Text({
                x: 10,
                y: 10,
                text: data.texts?.title?.text || '',
                fontSize: data.texts?.title?.fontSize || 16,
                fontFamily: 'Arial',
                fontStyle: 'bold',
                fill: 'black',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              const descText = new Konva.Text({
                x: 10,
                y: 40,
                text: data.texts?.desc?.text || '',
                fontSize: data.texts?.desc?.fontSize || 14,
                fontFamily: 'Arial',
                fill: 'black',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              const statusText = new Konva.Text({
                x: 10,
                y: bgAttrs.height - 30,
                text: data.texts?.status?.text || 'Статус: К выполнению',
                fontSize: data.texts?.status?.fontSize || 14,
                fontFamily: 'Arial',
                fill: data.texts?.status?.fill || '#ef4444',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              textNodes = [titleText, descText, statusText];
              group.on('dblclick', function() {
                editingTask = group;
                document.getElementById('task-modal').classList.remove('hidden');
                document.getElementById('task-title').value = titleText.text();
                document.getElementById('task-desc').value = descText.text();
                document.getElementById('task-status').value = statusText.text().replace('Статус: ', '');
                document.getElementById('task-role').value = data.role || 'Общий';
              });
            } else if (data.type === 'pdf') {
              const contentText = new Konva.Text({
                x: 10,
                y: 10,
                text: data.texts?.content?.text || '',
                fontSize: data.texts?.content?.fontSize || 14,
                fontFamily: 'Arial',
                fill: 'black',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              textNodes = [contentText];
              group.on('dblclick', function() {
                editingPdf = group;
                document.getElementById('pdf-modal').classList.remove('hidden');
                document.getElementById('pdf-content').value = contentText.text();
                document.getElementById('task-role').value = data.role || 'Общий';
              });
              group.on('dragend', handlePdfDragEnd);
            } else if (data.type === 'note') {
              const titleText = new Konva.Text({
                x: 10,
                y: 10,
                text: data.texts?.title?.text || '',
                fontSize: data.texts?.title?.fontSize || 16,
                fontFamily: 'Arial',
                fontStyle: 'bold',
                fill: 'black',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              const contentText = new Konva.Text({
                x: 10,
                y: 40,
                text: data.texts?.content?.text || '',
                fontSize: data.texts?.content?.fontSize || 14,
                fontFamily: 'Arial',
                fill: 'black',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              textNodes = [titleText, contentText];
              group.on('dblclick', function() {
                editingNote = group;
                document.getElementById('note-modal').classList.remove('hidden');
                document.getElementById('note-title').value = titleText.text();
                document.getElementById('note-content').value = contentText.text();
                document.getElementById('task-role').value = data.role || 'Общий';
              });
            } else if (data.type === 'comment') {
              const authorText = new Konva.Text({
                x: 10,
                y: 10,
                text: data.texts?.author?.text || '',
                fontSize: data.texts?.author?.fontSize || 14,
                fontFamily: 'Arial',
                fontStyle: 'italic',
                fill: '#000000',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              const contentText = new Konva.Text({
                x: 10,
                y: 40,
                text: data.texts?.content?.text || '',
                fontSize: data.texts?.content?.fontSize || 14,
                fontFamily: 'Arial',
                fill: '#000000',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              textNodes = [authorText, contentText];
              group.on('dblclick', function() {
                editingComment = group;
                document.getElementById('comment-modal').classList.remove('hidden');
                document.getElementById('comment-author').value = authorText.text().replace(/ \(.*\)/, '');
                document.getElementById('comment-content').value = contentText.text();
                document.getElementById('task-role').value = data.role || 'Общий';
              });
            } else if (data.type === 'text') {
              const contentText = new Konva.Text({
                x: 10,
                y: 10,
                text: data.texts?.content?.text || '',
                fontSize: data.texts?.content?.fontSize || 14,
                fontFamily: 'Arial',
                fill: 'white',
                width: bgAttrs.width - 20,
                padding: 5,
              });

              textNodes = [contentText];
              group.on('dblclick', function() {
                editingText = group;
                document.getElementById('text-modal').classList.remove('hidden');
                document.getElementById('text-content').value = contentText.text();
                document.getElementById('task-role').value = data.role || 'Общий';
              });
            }

            group.add(bg, ...textNodes);
            group.on('transform', function() {
              const scaleX = group.scaleX();
              const scaleY = group.scaleY();
              bg.width((group.width() / scaleX) || bgAttrs.width);
              bg.height((group.height() / scaleY) || bgAttrs.height);
              textNodes.forEach(function(text, index) {
                text.width(bg.width() - 20);
                if (data.type === 'task' && index === 2) {
                  text.y(bg.height() - 30);
                } else if (data.type === 'note' && index === 1) {
                  text.y(40);
                } else if (data.type === 'comment' && index === 1) {
                  text.y(40);
                }
              });
              group.scaleX(1);
              group.scaleY(1);
              saveBoard();
            });
            group.on('dragend', saveBoard);
            return group;
          }

          function updateRolesList() {
            const rolesList = document.getElementById('roles-list');
            rolesList.innerHTML = '';
            const allCanvases = ['Общий', ...Object.keys(roleAssignments)];
            allCanvases.forEach(function(role) {
              const li = document.createElement('li');
              li.className = `p-2 rounded cursor-pointer transition ${role === currentCanvas ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'} fade-in`;
              li.textContent = role;
              li.addEventListener('click', function() {
                if (!canvases[role]) canvases[role] = new Konva.Layer();
                currentCanvas = role;
                stage.getLayers().forEach(function(layer) {
                  if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
                });
                stage.add(canvases[role]);
                stage.batchDraw();
                updateRolesList();
              });
              rolesList.appendChild(li);
            });
            updateTaskRoleSelect();
          }

          function updateTaskRoleSelect() {
            const taskRoleSelect = document.getElementById('task-role');
            taskRoleSelect.innerHTML = '<option value="">Выберите роль</option>';
            const allRoles = ['Общий', ...Object.keys(roleAssignments)];
            allRoles.forEach(function(role) {
              const option = document.createElement('option');
              option.value = role;
              option.textContent = role;
              taskRoleSelect.appendChild(option);
            });
          }

          async function saveBoard() {
            const canvasData = {};
            Object.keys(canvases).forEach(function(role) {
              canvasData[role] = canvases[role].find('.Group').map(function(group) {
                const bg = group.findOne('Rect');
                const texts = group.find('.Text');
                return {
                  id: group.id(),
                  type: group.name(),
                  x: group.x(),
                  y: group.y(),
                  role: role,
                  scaleX: group.scaleX(),
                  scaleY: group.scaleY(),
                  bg: {
                    width: bg.width(),
                    height: bg.height(),
                    fill: bg.fill(),
                    stroke: bg.stroke(),
                    strokeWidth: bg.strokeWidth(),
                    cornerRadius: bg.cornerRadius(),
                    shadowColor: bg.shadowColor(),
                    shadowBlur: bg.shadowBlur(),
                    shadowOffset: bg.shadowOffset(),
                  },
                  texts: group.name() === 'task' ? {
                    title: { text: texts[0]?.text(), fontSize: texts[0]?.fontSize(), width: texts[0]?.width() },
                    desc: { text: texts[1]?.text(), fontSize: texts[1]?.fontSize(), width: texts[1]?.width() },
                    status: { text: texts[2]?.text(), fontSize: texts[2]?.fontSize(), fill: texts[2]?.fill(), width: texts[2]?.width() },
                  } : group.name() === 'pdf' ? {
                    content: { text: texts[0]?.text(), fontSize: texts[0]?.fontSize(), width: texts[0]?.width() },
                  } : group.name() === 'note' ? {
                    title: { text: texts[0]?.text(), fontSize: texts[0]?.fontSize(), width: texts[0]?.width() },
                    content: { text: texts[1]?.text(), fontSize: texts[1]?.fontSize(), width: texts[1]?.width() },
                  } : group.name() === 'comment' ? {
                    author: { text: texts[0]?.text(), fontSize: texts[0]?.fontSize(), width: texts[0]?.width() },
                    content: { text: texts[1]?.text(), fontSize: texts[1]?.fontSize(), width: texts[1]?.width() },
                  } : {
                    content: { text: texts[0]?.text(), fontSize: texts[0]?.fontSize(), width: texts[0]?.width() },
                  },
                };
              });
            });

            await updateDoc(doc(db, 'boards', currentBoardId), {
              canvases: canvasData,
              roleAssignments: roleAssignments,
            });
            console.log('Board saved:', currentBoardId);
          }

          const contextMenu = document.getElementById('context-menu');
          let contextTarget = null;
          let contextPos = { x: 0, y: 0 };
          stage.on('contextmenu touchend', function(e) {
            if (e.evt.type === 'touchend' && e.evt.touches && e.evt.touches.length > 1) return;
            e.evt.preventDefault();
            contextPos = stage.getPointerPosition();
            const intersection = stage.getIntersection(contextPos);
            contextTarget = null;

            (async function() {
              const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
              const isOwner = boardDoc.data().owner === currentUser.uid;
              const assignedUser = roleAssignments[currentCanvas];

              if (currentCanvas !== 'Общий' && !isOwner && assignedUser !== currentUser.uid) {
                return;
              }

              if (intersection) {
                const parent = intersection.getParent();
                if (parent && parent instanceof Konva.Group && ['task', 'pdf', 'note', 'comment', 'text'].includes(parent.name())) {
                  contextTarget = parent;
                }
              }

              document.getElementById('create-task').classList.toggle('hidden', !!contextTarget);
              document.getElementById('create-pdf').classList.toggle('hidden', !!contextTarget);
              document.getElementById('create-note').classList.toggle('hidden', !!contextTarget);
              document.getElementById('create-comment').classList.toggle('hidden', !!contextTarget);
              document.getElementById('create-text').classList.toggle('hidden', !!contextTarget);
              document.getElementById('delete-element').classList.toggle('hidden', !contextTarget);

              const clientX = e.evt.clientX || (e.evt.touches && e.evt.touches[0]?.clientX) || 0;
              const clientY = e.evt.clientY || (e.evt.touches && e.evt.touches[0]?.clientY) || 0;
              contextMenu.style.left = `${clientX}px`;
              contextMenu.style.top = `${clientY}px`;
              contextMenu.classList.remove('hidden');
              console.log('Opened context menu at:', clientX, clientY, 'target:', contextTarget ? contextTarget.name() : 'none');
            })();
          });

          document.addEventListener('click', function(e) {
            if (!contextMenu.contains(e.target)) {
              contextMenu.classList.add('hidden');
              contextTarget = null;
            }
          });

          document.addEventListener('touchstart', function(e) {
            if (!contextMenu.contains(e.target) && e.touches.length === 1) {
              contextMenu.classList.add('hidden');
              contextTarget = null;
            }
          });

          stage.on('click tap', function(e) {
            const pos = stage.getPointerPosition();
            const intersection = stage.getIntersection(pos);
            if (!intersection || intersection.getLayer() === backgroundLayer) {
              transformer.nodes([]);
            } else {
              const parent = intersection.getParent();
              if (parent && parent instanceof Konva.Group && ['task', 'pdf', 'note', 'comment', 'text'].includes(parent.name())) {
                transformer.nodes([parent]);
                console.log('Selected element for transform:', parent.name());
              } else {
                transformer.nodes([]);
              }
            }
            stage.batchDraw();
          });

          let editingTask = null;
          document.getElementById('create-task').addEventListener('click', function() {
            contextMenu.classList.add('hidden');
            document.getElementById('task-modal').classList.remove('hidden');
            document.getElementById('task-title').value = '';
            document.getElementById('task-desc').value = '';
            editingTask = null;
          });

          document.getElementById('cancel-task').addEventListener('click', function() {
            document.getElementById('task-modal').classList.add('hidden');
            document.getElementById('task-title').value = '';
            document.getElementById('task-desc').value = '';
          });

          document.getElementById('save-task').addEventListener('click', async function() {
            const title = document.getElementById('task-title').value.trim();
            const desc = document.getElementById('task-desc').value.trim();
            const status = document.getElementById('task-status').value;
            const role = document.getElementById('task-role').value || 'Общий';

            if (!title || !desc) {
              alert('Заполните заголовок и описание');
              return;
            }

            const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
            const isOwner = boardDoc.data().owner === currentUser.uid;
            const assignedUser = roleAssignments[role];

            if (role !== 'Общий' && !isOwner && assignedUser !== currentUser.uid) {
              alert('У вас нет прав для редактирования этого холста');
              return;
            }

            if (!canvases[role]) {
              canvases[role] = new Konva.Layer();
            }

            let card;
            if (editingTask) {
              card = editingTask;
              const textNodes = card.find('.Text');
              textNodes[0].text(title);
              textNodes[1].text(desc);
              textNodes[2].text(`Статус: ${status}`);
              textNodes[2].fill(status === 'Завершено' ? '#22c55e' : status === 'В процессе' ? '#f59e0b' : '#ef4444');
              editingTask = null;
            } else {
              card = new Konva.Group({
                x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
                y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
                draggable: true,
                name: 'task',
                id: `task-${Date.now()}`,
              });

              const bg = new Konva.Rect({
                width: 200,
                height: 150,
                fill: '#ffffff',
                stroke: '#d1d5db',
                strokeWidth: 2,
                cornerRadius: 8,
                shadowColor: 'rgba(0,0,0,0.2)',
                shadowBlur: 10,
                shadowOffset: { x: 2, y: 2 },
              });

              const titleText = new Konva.Text({
                x: 10,
                y: 10,
                text: title,
                fontSize: 16,
                fontFamily: 'Arial',
                fontStyle: 'bold',
                fill: 'black',
                width: 180,
                padding: 5,
              });

              const descText = new Konva.Text({
                x: 10,
                y: 40,
                text: desc,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: 'black',
                width: 180,
                padding: 5,
              });

              const statusText = new Konva.Text({
                x: 10,
                y: 120,
                text: `Статус: ${status}`,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: status === 'Завершено' ? '#22c55e' : status === 'В процессе' ? '#f59e0b' : '#ef4444',
                width: 180,
                padding: 5,
              });

              card.add(bg, titleText, descText, statusText);
              canvases[role].add(card);

              card.on('dblclick', function() {
                editingTask = card;
                document.getElementById('task-modal').classList.remove('hidden');
                document.getElementById('task-title').value = titleText.text();
                document.getElementById('task-desc').value = descText.text();
                document.getElementById('task-status').value = statusText.text().replace('Статус: ', '');
                document.getElementById('task-role').value = role;
              });

              card.on('transform', function() {
                const scaleX = card.scaleX();
                const scaleY = card.scaleY();
                bg.width(card.width() / scaleX);
                bg.height(card.height() / scaleY);
                titleText.width(bg.width() - 20);
                descText.width(bg.width() - 20);
                statusText.width(bg.width() - 20);
                statusText.y(bg.height() - 30);
                card.scaleX(1);
                card.scaleY(1);
                saveBoard();
              });
              card.on('dragend', saveBoard);
            }

            if (currentCanvas === role) {
              stage.getLayers().forEach(function(layer) {
                if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
              });
              stage.add(canvases[role]);
              stage.batchDraw();
            }
            document.getElementById('task-modal').classList.add('hidden');
            document.getElementById('task-title').value = '';
            document.getElementById('task-desc').value = '';
            await saveBoard();
          });

          let editingPdf = null;
          document.getElementById('create-pdf').addEventListener('click', function() {
            contextMenu.classList.add('hidden');
            document.getElementById('pdf-modal').classList.remove('hidden');
            document.getElementById('pdf-content').value = '';
            editingPdf = null;
          });

          document.getElementById('cancel-pdf').addEventListener('click', function() {
            document.getElementById('pdf-modal').classList.add('hidden');
            document.getElementById('pdf-content').value = '';
          });

          function handlePdfDragEnd() {
            const pdfPos = this.getAbsolutePosition();
            const pdfSize = { width: this.width(), height: this.height() };
            canvases[currentCanvas].find('.task').forEach(function(task) {
              const taskPos = task.getAbsolutePosition();
              if (
                taskPos.x >= pdfPos.x &&
                taskPos.x <= pdfPos.x + pdfSize.width &&
                taskPos.y >= pdfPos.y &&
                taskPos.y <= pdfPos.y + pdfSize.height
              ) {
                task.moveTo(this);
              }
            });
            stage.batchDraw();
            saveBoard();
          }

          document.getElementById('save-pdf').addEventListener('click', async function() {
            const content = document.getElementById('pdf-content').value.trim();
            const role = document.getElementById('task-role').value || 'Общий';

            if (!content) {
              alert('Введите содержимое PDF');
              return;
            }

            const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
            const isOwner = boardDoc.data().owner === currentUser.uid;
            const assignedUser = roleAssignments[role];

            if (role !== 'Общий' && !isOwner && assignedUser !== currentUser.uid) {
              alert('У вас нет прав для редактирования этого холста');
              return;
            }

            if (!canvases[role]) {
              canvases[role] = new Konva.Layer();
            }

            let pdfGroup;
            if (editingPdf) {
              pdfGroup = editingPdf;
              pdfGroup.findOne('Text').text(content);
              editingPdf = null;
            } else {
              pdfGroup = new Konva.Group({
                x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
                y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
                draggable: true,
                name: 'pdf',
                id: `pdf-${Date.now()}`,
              });

              const bg = new Konva.Rect({
                width: 300,
                height: 400,
                fill: '#f8f8f8',
                stroke: '#d1d5db',
                strokeWidth: 2,
                cornerRadius: 8,
                shadowColor: 'rgba(0,0,0,0.2)',
                shadowBlur: 10,
                shadowOffset: { x: 2, y: 2 },
              });

              const text = new Konva.Text({
                x: 10,
                y: 10,
                text: content,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: 'black',
                width: 280,
                padding: 5,
              });

              pdfGroup.add(bg, text);
              canvases[role].add(pdfGroup);

              pdfGroup.on('dblclick', function() {
                editingPdf = pdfGroup;
                document.getElementById('pdf-modal').classList.remove('hidden');
                document.getElementById('pdf-content').value = text.text();
                document.getElementById('task-role').value = role;
              });

              pdfGroup.on('dragend', handlePdfDragEnd);
              pdfGroup.on('transform', function() {
                const scaleX = pdfGroup.scaleX();
                const scaleY = pdfGroup.scaleY();
                bg.width(pdfGroup.width() / scaleX);
                bg.height(pdfGroup.height() / scaleY);
                text.width(bg.width() - 20);
                pdfGroup.scaleX(1);
                pdfGroup.scaleY(1);
                saveBoard();
              });
            }

            if (currentCanvas === role) {
              stage.getLayers().forEach(function(layer) {
                if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
              });
              stage.add(canvases[role]);
              stage.batchDraw();
            }
            document.getElementById('pdf-modal').classList.add('hidden');
            document.getElementById('pdf-content').value = '';
            await saveBoard();
          });

          let editingNote = null;
          document.getElementById('create-note').addEventListener('click', function() {
            contextMenu.classList.add('hidden');
            document.getElementById('note-modal').classList.remove('hidden');
            document.getElementById('note-title').value = '';
            document.getElementById('note-content').value = '';
            editingNote = null;
          });

          document.getElementById('cancel-note').addEventListener('click', function() {
            document.getElementById('note-modal').classList.add('hidden');
            document.getElementById('note-title').value = '';
            document.getElementById('note-content').value = '';
          });

          document.getElementById('save-note').addEventListener('click', async function() {
            const title = document.getElementById('note-title').value.trim();
            const content = document.getElementById('note-content').value.trim();
            const role = document.getElementById('task-role').value || 'Общий';

            if (!title || !content) {
              alert('Заполните заголовок и содержимое');
              return;
            }

            const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
            const isOwner = boardDoc.data().owner === currentUser.uid;
            const assignedUser = roleAssignments[role];

            if (role !== 'Общий' && !isOwner && assignedUser !== currentUser.uid) {
              alert('У вас нет прав для редактирования этого холста');
              return;
            }

            if (!canvases[role]) {
              canvases[role] = new Konva.Layer();
            }

            let noteGroup;
            if (editingNote) {
              noteGroup = editingNote;
              const textNodes = noteGroup.find('.Text');
              textNodes[0].text(title);
              textNodes[1].text(content);
              editingNote = null;
            } else {
              noteGroup = new Konva.Group({
                x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
                y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
                draggable: true,
                name: 'note',
                id: `note-${Date.now()}`,
              });

              const bg = new Konva.Rect({
                width: 200,
                height: 150,
                fill: '#fefcbf',
                stroke: '#d1d5db',
                strokeWidth: 2,
                cornerRadius: 8,
                shadowColor: 'rgba(0,0,0,0.2)',
                shadowBlur: 10,
                shadowOffset: { x: 2, y: 2 },
              });

              const titleText = new Konva.Text({
                x: 10,
                y: 10,
                text: title,
                fontSize: 16,
                fontFamily: 'Arial',
                fontStyle: 'bold',
                fill: 'black',
                width: 180,
                padding: 5,
              });

              const contentText = new Konva.Text({
                x: 10,
                y: 40,
                text: content,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: 'black',
                width: 180,
                padding: 5,
              });

              noteGroup.add(bg, titleText, contentText);
              canvases[role].add(noteGroup);

              noteGroup.on('dblclick', function() {
                editingNote = noteGroup;
                document.getElementById('note-modal').classList.remove('hidden');
                document.getElementById('note-title').value = titleText.text();
                document.getElementById('note-content').value = contentText.text();
                document.getElementById('task-role').value = role;
              });

              noteGroup.on('transform', function() {
                const scaleX = noteGroup.scaleX();
                const scaleY = noteGroup.scaleY();
                bg.width(noteGroup.width() / scaleX);
                bg.height(noteGroup.height() / scaleY);
                titleText.width(bg.width() - 20);
                contentText.width(bg.width() - 20);
                noteGroup.scaleX(1);
                noteGroup.scaleY(1);
                saveBoard();
              });
              noteGroup.on('dragend', saveBoard);
            }

            if (currentCanvas === role) {
              stage.getLayers().forEach(function(layer) {
                if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
              });
              stage.add(canvases[role]);
              stage.batchDraw();
            }
            document.getElementById('note-modal').classList.add('hidden');
            document.getElementById('note-title').value = '';
            document.getElementById('note-content').value = '';
            await saveBoard();
          });

          let editingComment = null;
          document.getElementById('create-comment').addEventListener('click', function() {
            contextMenu.classList.add('hidden');
            document.getElementById('comment-modal').classList.remove('hidden');
            document.getElementById('comment-author').value = currentUser.displayName || currentUser.email || 'Пользователь';
            document.getElementById('comment-content').value = '';
            editingComment = null;
          });

          document.getElementById('cancel-comment').addEventListener('click', function() {
            document.getElementById('comment-modal').classList.add('hidden');
            document.getElementById('comment-author').value = '';
            document.getElementById('comment-content').value = '';
          });

          document.getElementById('save-comment').addEventListener('click', async function() {
            const author = document.getElementById('comment-author').value.trim();
            const content = document.getElementById('comment-content').value.trim();
            const role = document.getElementById('task-role').value || 'Общий';

            if (!author || !content) {
              alert('Заполните автора и содержимое');
              return;
            }

            const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
            const isOwner = boardDoc.data().owner === currentUser.uid;
            const assignedUser = roleAssignments[role];

            if (role !== 'Общий' && !isOwner && assignedUser !== currentUser.uid) {
              alert('У вас нет прав для редактирования этого холста');
              return;
            }

            const date = new Date().toLocaleString('ru-RU');
            if (!canvases[role]) {
              canvases[role] = new Konva.Layer();
            }

            let commentGroup;
            if (editingComment) {
              commentGroup = editingComment;
              const textNodes = commentGroup.find('.Text');
              textNodes[0].text(`От: ${author} (${date})`);
              textNodes[1].text(content);
              editingComment = null;
            } else {
              commentGroup = new Konva.Group({
                x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
                y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
                draggable: true,
                name: 'comment',
                id: `comment-${Date.now()}`,
              });

              const bg = new Konva.Rect({
                width: 200,
                height: 150,
                fill: '#e5e7eb',
                stroke: '#d1d5db',
                strokeWidth: 2,
                cornerRadius: 8,
                shadowColor: 'rgba(0,0,0,0.2)',
                shadowBlur: 10,
                shadowOffset: { x: 0, y: 2 },
              });

              const authorText = new Konva.Text({
                x: 10,
                y: 10,
                text: `От: ${author} (${date})`,
                fontSize: 14,
                fontFamily: 'Arial',
                fontStyle: 'italic',
                fill: '#000000',
                width: 180,
                padding: 5,
              });

              const contentText = new Konva.Text({
                x: 10,
                y: 40,
                text: content,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: '#000000',
                width: 180,
                padding: 5,
              });

              commentGroup.add(bg, authorText, contentText);
              canvases[role].add(commentGroup);

              commentGroup.on('dblclick', function() {
                editingComment = commentGroup;
                document.getElementById('comment-modal').classList.remove('hidden');
                document.getElementById('comment-author').value = authorText.text().replace(/ \(.*\)/, '');
                document.getElementById('comment-content').value = contentText.text();
                document.getElementById('task-role').value = role;
              });

              commentGroup.on('transform', function() {
                const scaleX = commentGroup.scaleX();
                const scaleY = commentGroup.scaleY();
                bg.width(commentGroup.width() / scaleX);
                bg.height(commentGroup.height() / scaleY);
                authorText.width(bg.width() - 20);
                contentText.width(bg.width() - 20);
                commentGroup.scaleX(1);
                commentGroup.scaleY(1);
                saveBoard();
              });
              commentGroup.on('dragend', saveBoard);
            }

            if (currentCanvas === role) {
              stage.getLayers().forEach(function(layer) {
                if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
              });
              stage.add(canvases[role]);
              stage.batchDraw();
            }
            document.getElementById('comment-modal').classList.add('hidden');
            document.getElementById('comment-author').value = '';
            document.getElementById('comment-content').value = '';
            await saveBoard();
          });

          let editingText = null;
          document.getElementById('create-text').addEventListener('click', function() {
            contextMenu.classList.add('hidden');
            document.getElementById('text-modal').classList.remove('hidden');
            document.getElementById('text-content').value = '';
            editingText = null;
          });

          document.getElementById('cancel-text').addEventListener('click', function() {
            document.getElementById('text-modal').classList.add('hidden');
            document.getElementById('text-content').value = '';
          });

          document.getElementById('save-text').addEventListener('click', async function() {
            const content = document.getElementById('text-content').value.trim();
            const role = document.getElementById('task-role').value || 'Общий';

            if (!content) {
              alert('Введите текст');
              return;
            }

            const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
            const isOwner = boardDoc.data().owner === currentUser.uid;
            const assignedUser = roleAssignments[role];

            if (role !== 'Общий' && !isOwner && assignedUser !== currentUser.uid) {
              alert('У вас нет прав для редактирования этого холста');
              return;
            }

            if (!canvases[role]) {
              canvases[role] = new Konva.Layer();
            }

            let textGroup;
            if (editingText) {
              textGroup = editingText;
              textGroup.findOne('Text').text(content);
              editingText = null;
            } else {
              textGroup = new Konva.Group({
                x: contextPos.x / stage.scaleX() - stage.x() / stage.scaleX(),
                y: contextPos.y / stage.scaleY() - stage.y() / stage.scaleY(),
                draggable: true,
                name: 'text',
                id: `text-${Date.now()}`,
              });

              const bg = new Konva.Rect({
                width: 200,
                height: 100,
                fill: 'transparent',
                stroke: '#d1d5db',
                strokeWidth: 1,
              });

              const contentText = new Konva.Text({
                x: 10,
                y: 10,
                text: content,
                fontSize: 14,
                fontFamily: 'Arial',
                fill: 'white',
                width: 180,
                padding: 5,
              });

              textGroup.add(bg, contentText);
              canvases[role].add(textGroup);

              textGroup.on('dblclick', function() {
                editingText = textGroup;
                document.getElementById('text-modal').classList.remove('hidden');
                document.getElementById('text-content').value = contentText.text();
                document.getElementById('task-role').value = role;
              });

              textGroup.on('transform', function() {
                const scaleX = textGroup.scaleX();
                const scaleY = textGroup.scaleY();
                bg.width(textGroup.width() / scaleX);
                bg.height(textGroup.height() / scaleY);
                contentText.width(bg.width() - 20);
                textGroup.scaleX(1);
                textGroup.scaleY(1);
                saveBoard();
              });
              textGroup.on('dragend', saveBoard);
            }

            if (currentCanvas === role) {
              stage.getLayers().forEach(function(layer) {
                if (layer !== backgroundLayer && layer !== transformerLayer) layer.remove();
              });
              stage.add(canvases[role]);
              stage.batchDraw();
            }
            document.getElementById('text-modal').classList.add('hidden');
            document.getElementById('text-content').value = '';
            await saveBoard();
          });

          document.getElementById('delete-element').addEventListener('click', async function() {
            if (contextTarget) {
              const boardDoc = await getDoc(doc(db, 'boards', currentBoardId));
              const isOwner = boardDoc.data().owner === currentUser.uid;
              const assignedUser = roleAssignments[currentCanvas];

              if (currentCanvas !== 'Общий' && !isOwner && assignedUser !== currentUser.uid) {
                alert('У вас нет прав для удаления элементов на этом холсте');
                return;
              }

              contextTarget.destroy();
              transformer.nodes([]);
              stage.batchDraw();
              contextMenu.classList.add('hidden');
              contextTarget = null;
              await saveBoard();
            }
          });

          const adminPanel = document.getElementById('admin-panel');
          document.getElementById('toggle-admin').addEventListener('click', function() {
            const isHidden = adminPanel.classList.contains('hidden');
            adminPanel.classList.toggle('hidden');
            if (isHidden) {
              adminPanel.classList.add('slide-in', 'open');
            } else {
              adminPanel.classList.remove('slide-in', 'open');
            }
            sidebar.classList.remove('open');
            sidebar.style.left = '-256px';
          });

          document.getElementById('generate-link').addEventListener('click', function() {
            const link = `https://app.example.com/invite/${currentBoardId}`;
            document.getElementById('invite-link').value = link;
          });

          document.getElementById('add-role').addEventListener('click', async function() {
            const roleInput = document.getElementById('role-input').value.trim();
            const userUid = document.getElementById('user-select').value;

            if (!roleInput) {
              alert('Введите название роли');
              return;
            }
            if (!userUid) {
              alert('Выберите пользователя');
              return;
            }
            if (roleAssignments[roleInput]) {
              alert('Роль уже существует');
              return;
            }

            roleAssignments[roleInput] = userUid;
            canvases[roleInput] = new Konva.Layer();
            updateRolesList();
            document.getElementById('role-input').value = '';
            document.getElementById('user-select').value = '';
            await saveBoard();
          });

          let scale = 1;
          stage.on('wheel', function(e) {
            e.evt.preventDefault();
            const oldScale = scale;
            const pointer = stage.getPointerPosition();
            const mousePointTo = {
              x: pointer.x / oldScale - stage.x() / oldScale,
              y: pointer.y / oldScale - stage.y() / oldScale,
            };

            const deltaY = e.evt.deltaY;
            scale = deltaY > 0 ? scale * 0.9 : scale / 0.9;
            scale = Math.max(0.5, Math.min(scale, 3));

            stage.scale({ x: scale, y: scale });
            const newPos = {
              x: -(mousePointTo.x - pointer.x / scale) * scale,
              y: -(mousePointTo.y - pointer.y / scale) * scale,
            };
            stage.position(newPos);
            updateGrid();
            stage.batchDraw();
          });

          let lastDist = 0;
          let startPos = { x: 0, y: 0 };
          stage.on('touchstart', function(e) {
            if (e.evt.touches.length === 2) {
              lastDist = Math.hypot(
                e.evt.touches[0].clientX - e.evt.touches[1].clientX,
                e.evt.touches[0].clientY - e.evt.touches[1].clientY
              );
            } else if (e.evt.touches.length === 1) {
              startPos = stage.getPointerPosition();
            }
          });

          stage.on('touchmove', function(e) {
            if (e.evt.touches.length === 2) {
              const newDist = Math.hypot(
                e.evt.touches[0].clientX - e.evt.touches[1].clientX,
                e.evt.touches[0].clientY - e.evt.touches[1].clientY
              );
              if (lastDist > 0) {
                const oldScale = scale;
                scale *= newDist / lastDist;
                scale = Math.max(0.5, Math.min(scale, 3));
                const pointer = {
                  x: (e.evt.touches[0].clientX + e.evt.touches[1].clientX) / 2,
                  y: (e.evt.touches[0].clientY + e.evt.touches[1].clientY) / 2,
                };
                const mousePointTo = {
                  x: pointer.x / oldScale - stage.x() / oldScale,
                  y: pointer.y / oldScale - stage.y() / oldScale,
                };
                stage.scale({ x: scale, y: scale });
                const newPos = {
                  x: -(mousePointTo.x - pointer.x / scale) * scale,
                  y: -(mousePointTo.y - pointer.y / scale) * scale,
                };
                stage.position(newPos);
                lastDist = newDist;
                updateGrid();
                stage.batchDraw();
              }
            } else if (e.evt.touches.length === 1) {
              const pos = stage.getPointerPosition();
              stage.position({
                x: stage.x() + pos.x - startPos.x,
                y: stage.y() + pos.y - startPos.y,
              });
              startPos = pos;
              updateGrid();
              stage.batchDraw();
            }
          });

          stage.on('touchend', function() {
            lastDist = 0;
          });

          window.addEventListener('resize', function() {
            stage.width(window.innerWidth);
            stage.height(window.innerHeight);
            updateGrid();
            stage.batchDraw();
          });
        }
      } catch (error) {
        console.error('Initialization error:', error);
        alert('Ошибка инициализации приложения. Проверьте консоль браузера.');
      }
    };
  </script>
</body>
</html>